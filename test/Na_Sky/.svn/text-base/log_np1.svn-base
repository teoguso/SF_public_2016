 Reading invar file...  Done.
 minband = 5
 maxband = 5
 nband = 1
 minkpt = 1
 maxkpt = 145
 nkpt = 145
 enmin = -30.0
 enmax = 15.0
 S prefactor: 1.0
 P prefactor: 0.0
 Reading file hartree.dat...  Done.
 enmin, enmax
-30.0 15.0
 Reading array of energies from first k-point in _SIG file...  Done.
 Length of the energy array detected from _SIG file, first k point: 1400
 len(en): 1400
 size(en): 1400
 dx: 0.1
en[0], en[-1]
-120.0 20.0
 kpt # 01
# k =   0.000000  0.000000  0.000000
# b =          1         5
 kpt # 02
# k =   0.062500  0.000000  0.000000
# b =          1         5
 kpt # 03
# k =   0.125000  0.000000  0.000000
# b =          1         5
 kpt # 04
# k =   0.187500  0.000000  0.000000
# b =          1         5
 kpt # 05
# k =   0.250000  0.000000  0.000000
# b =          1         5
 kpt # 06
# k =   0.312500  0.000000  0.000000
# b =          1         5
 kpt # 07
# k =   0.375000  0.000000  0.000000
# b =          1         5
 kpt # 08
# k =   0.437500  0.000000  0.000000
# b =          1         5
 kpt # 09
# k =   0.500000  0.000000  0.000000
# b =          1         5
 kpt # 10
# k =   0.062500  0.062500  0.000000
# b =          1         5
 kpt # 11
# k =   0.125000  0.062500  0.000000
# b =          1         5
 kpt # 12
# k =   0.187500  0.062500  0.000000
# b =          1         5
 kpt # 13
# k =   0.250000  0.062500  0.000000
# b =          1         5
 kpt # 14
# k =   0.312500  0.062500  0.000000
# b =          1         5
 kpt # 15
# k =   0.375000  0.062500  0.000000
# b =          1         5
 kpt # 16
# k =   0.437500  0.062500  0.000000
# b =          1         5
 kpt # 17
# k =   0.125000  0.125000  0.000000
# b =          1         5
 kpt # 18
# k =   0.187500  0.125000  0.000000
# b =          1         5
 kpt # 19
# k =   0.250000  0.125000  0.000000
# b =          1         5
 kpt # 20
# k =   0.312500  0.125000  0.000000
# b =          1         5
 kpt # 21
# k =   0.375000  0.125000  0.000000
# b =          1         5
 kpt # 22
# k =   0.437500  0.125000  0.000000
# b =          1         5
 kpt # 23
# k =   0.187500  0.187500  0.000000
# b =          1         5
 kpt # 24
# k =   0.250000  0.187500  0.000000
# b =          1         5
 kpt # 25
# k =   0.312500  0.187500  0.000000
# b =          1         5
 kpt # 26
# k =   0.375000  0.187500  0.000000
# b =          1         5
 kpt # 27
# k =   0.250000  0.250000  0.000000
# b =          1         5
 kpt # 28
# k =   0.312500  0.250000  0.000000
# b =          1         5
 kpt # 29
# k =   0.375000  0.250000  0.000000
# b =          1         5
 kpt # 30
# k =   0.312500  0.312500  0.000000
# b =          1         5
 kpt # 31
# k =   0.062500  0.062500  0.062500
# b =          1         5
 kpt # 32
# k =   0.125000  0.062500  0.062500
# b =          1         5
 kpt # 33
# k =   0.187500  0.062500  0.062500
# b =          1         5
 kpt # 34
# k =   0.250000  0.062500  0.062500
# b =          1         5
 kpt # 35
# k =   0.312500  0.062500  0.062500
# b =          1         5
 kpt # 36
# k =   0.375000  0.062500  0.062500
# b =          1         5
 kpt # 37
# k =   0.437500  0.062500  0.062500
# b =          1         5
 kpt # 38
# k =  -0.062500  0.062500  0.062500
# b =          1         5
 kpt # 39
# k =   0.125000  0.125000  0.062500
# b =          1         5
 kpt # 40
# k =   0.187500  0.125000  0.062500
# b =          1         5
 kpt # 41
# k =   0.250000  0.125000  0.062500
# b =          1         5
 kpt # 42
# k =   0.312500  0.125000  0.062500
# b =          1         5
 kpt # 43
# k =   0.375000  0.125000  0.062500
# b =          1         5
 kpt # 44
# k =  -0.125000  0.125000  0.062500
# b =          1         5
 kpt # 45
# k =   0.187500  0.187500  0.062500
# b =          1         5
 kpt # 46
# k =   0.250000  0.187500  0.062500
# b =          1         5
 kpt # 47
# k =   0.312500  0.187500  0.062500
# b =          1         5
 kpt # 48
# k =   0.375000  0.187500  0.062500
# b =          1         5
 kpt # 49
# k =  -0.187500  0.187500  0.062500
# b =          1         5
 kpt # 50
# k =  -0.125000  0.187500  0.062500
# b =          1         5
 kpt # 51
# k =   0.250000  0.250000  0.062500
# b =          1         5
 kpt # 52
# k =   0.312500  0.250000  0.062500
# b =          1         5
 kpt # 53
# k =  -0.250000  0.250000  0.062500
# b =          1         5
 kpt # 54
# k =  -0.187500  0.250000  0.062500
# b =          1         5
 kpt # 55
# k =   0.312500  0.312500  0.062500
# b =          1         6
 kpt # 56
# k =  -0.312500  0.312500  0.062500
# b =          1         5
 kpt # 57
# k =  -0.250000  0.312500  0.062500
# b =          1         5
 kpt # 58
# k =  -0.187500  0.312500  0.062500
# b =          1         5
 kpt # 59
# k =  -0.375000  0.375000  0.062500
# b =          1         5
 kpt # 60
# k =  -0.312500  0.375000  0.062500
# b =          1         5
 kpt # 61
# k =  -0.250000  0.375000  0.062500
# b =          1         5
 kpt # 62
# k =  -0.437500  0.437500  0.062500
# b =          1         5
 kpt # 63
# k =  -0.375000  0.437500  0.062500
# b =          1         5
 kpt # 64
# k =  -0.312500  0.437500  0.062500
# b =          1         5
 kpt # 65
# k =  -0.250000  0.437500  0.062500
# b =          1         5
 kpt # 66
# k =   0.500000  0.500000  0.062500
# b =          1         5
 kpt # 67
# k =  -0.437500  0.500000  0.062500
# b =          1         5
 kpt # 68
# k =  -0.375000  0.500000  0.062500
# b =          1         5
 kpt # 69
# k =  -0.312500  0.500000  0.062500
# b =          1         5
 kpt # 70
# k =  -0.437500 -0.437500  0.062500
# b =          1         5
 kpt # 71
# k =  -0.375000 -0.437500  0.062500
# b =          1         5
 kpt # 72
# k =  -0.312500 -0.437500  0.062500
# b =          1         5
 kpt # 73
# k =  -0.375000 -0.375000  0.062500
# b =          1         5
 kpt # 74
# k =   0.125000  0.125000  0.125000
# b =          1         5
 kpt # 75
# k =   0.187500  0.125000  0.125000
# b =          1         5
 kpt # 76
# k =   0.250000  0.125000  0.125000
# b =          1         5
 kpt # 77
# k =   0.312500  0.125000  0.125000
# b =          1         5
 kpt # 78
# k =   0.375000  0.125000  0.125000
# b =          1         5
 kpt # 79
# k =  -0.125000  0.125000  0.125000
# b =          1         5
 kpt # 80
# k =   0.187500  0.187500  0.125000
# b =          1         5
 kpt # 81
# k =   0.250000  0.187500  0.125000
# b =          1         5
 kpt # 82
# k =   0.312500  0.187500  0.125000
# b =          1         5
 kpt # 83
# k =  -0.187500  0.187500  0.125000
# b =          1         5
 kpt # 84
# k =   0.250000  0.250000  0.125000
# b =          1         5
 kpt # 85
# k =   0.312500  0.250000  0.125000
# b =          1         5
 kpt # 86
# k =  -0.250000  0.250000  0.125000
# b =          1         5
 kpt # 87
# k =  -0.187500  0.250000  0.125000
# b =          1         5
 kpt # 88
# k =  -0.312500  0.312500  0.125000
# b =          1         5
 kpt # 89
# k =  -0.250000  0.312500  0.125000
# b =          1         5
 kpt # 90
# k =  -0.375000  0.375000  0.125000
# b =          1         5
 kpt # 91
# k =  -0.312500  0.375000  0.125000
# b =          1         5
 kpt # 92
# k =  -0.250000  0.375000  0.125000
# b =          1         5
 kpt # 93
# k =  -0.437500  0.437500  0.125000
# b =          1         5
 kpt # 94
# k =  -0.375000  0.437500  0.125000
# b =          1         5
 kpt # 95
# k =  -0.312500  0.437500  0.125000
# b =          1         5
 kpt # 96
# k =   0.500000  0.500000  0.125000
# b =          1         5
 kpt # 97
# k =  -0.437500  0.500000  0.125000
# b =          1         5
 kpt # 98
# k =  -0.375000  0.500000  0.125000
# b =          1         5
 kpt # 99
# k =  -0.312500  0.500000  0.125000
# b =          1         5
 kpt # 100
# k =  -0.437500 -0.437500  0.125000
# b =          1         5
 kpt # 101
# k =  -0.375000 -0.437500  0.125000
# b =          1         5
 kpt # 102
# k =  -0.375000 -0.375000  0.125000
# b =          1         6
 kpt # 103
# k =   0.187500  0.187500  0.187500
# b =          1         5
 kpt # 104
# k =   0.250000  0.187500  0.187500
# b =          1         5
 kpt # 105
# k =   0.312500  0.187500  0.187500
# b =          1         5
 kpt # 106
# k =  -0.187500  0.187500  0.187500
# b =          1         5
 kpt # 107
# k =   0.250000  0.250000  0.187500
# b =          1         5
 kpt # 108
# k =  -0.250000  0.250000  0.187500
# b =          1         5
 kpt # 109
# k =  -0.312500  0.312500  0.187500
# b =          1         5
 kpt # 110
# k =  -0.250000  0.312500  0.187500
# b =          1         5
 kpt # 111
# k =  -0.375000  0.375000  0.187500
# b =          1         5
 kpt # 112
# k =  -0.312500  0.375000  0.187500
# b =          1         5
 kpt # 113
# k =  -0.437500  0.437500  0.187500
# b =          1         5
 kpt # 114
# k =  -0.375000  0.437500  0.187500
# b =          1         5
 kpt # 115
# k =  -0.312500  0.437500  0.187500
# b =          1         5
 kpt # 116
# k =   0.500000  0.500000  0.187500
# b =          1         5
 kpt # 117
# k =  -0.437500  0.500000  0.187500
# b =          1         5
 kpt # 118
# k =  -0.375000  0.500000  0.187500
# b =          1         5
 kpt # 119
# k =  -0.437500 -0.437500  0.187500
# b =          1         5
 kpt # 120
# k =  -0.375000 -0.437500  0.187500
# b =          1         5
 kpt # 121
# k =   0.250000  0.250000  0.250000
# b =          1         7
 kpt # 122
# k =  -0.250000  0.250000  0.250000
# b =          1         5
 kpt # 123
# k =  -0.312500  0.312500  0.250000
# b =          1         5
 kpt # 124
# k =  -0.375000  0.375000  0.250000
# b =          1         5
 kpt # 125
# k =  -0.312500  0.375000  0.250000
# b =          1         5
 kpt # 126
# k =  -0.437500  0.437500  0.250000
# b =          1         5
 kpt # 127
# k =  -0.375000  0.437500  0.250000
# b =          1         5
 kpt # 128
# k =   0.500000  0.500000  0.250000
# b =          1         5
 kpt # 129
# k =  -0.437500  0.500000  0.250000
# b =          1         5
 kpt # 130
# k =  -0.375000  0.500000  0.250000
# b =          1         5
 kpt # 131
# k =  -0.437500 -0.437500  0.250000
# b =          1         5
 kpt # 132
# k =  -0.312500  0.312500  0.312500
# b =          1         5
 kpt # 133
# k =  -0.375000  0.375000  0.312500
# b =          1         5
 kpt # 134
# k =  -0.437500  0.437500  0.312500
# b =          1         5
 kpt # 135
# k =  -0.375000  0.437500  0.312500
# b =          1         5
 kpt # 136
# k =   0.500000  0.500000  0.312500
# b =          1         5
 kpt # 137
# k =  -0.437500  0.500000  0.312500
# b =          1         5
 kpt # 138
# k =  -0.437500 -0.437500  0.312500
# b =          1         6
 kpt # 139
# k =  -0.375000  0.375000  0.375000
# b =          1         5
 kpt # 140
# k =  -0.437500  0.437500  0.375000
# b =          1         5
 kpt # 141
# k =   0.500000  0.500000  0.375000
# b =          1         5
 kpt # 142
# k =  -0.437500  0.500000  0.375000
# b =          1         5
 kpt # 143
# k =  -0.437500  0.437500  0.437500
# b =          1         5
 kpt # 144
# k =   0.500000  0.500000  0.437500
# b =          1         5
 kpt # 145
# k =   0.500000  0.500000  0.500000
# b =          1         6
en[0], en[-1], enmin, enmax
-121.33332 18.66668 -30.0 15.0
 ### nkpt, nband: 145 1
 # ------------------------------------------------ # 
 ### Reading cross sections...  
 Photon energy: 800 eV
 csfilename: cs800.dat
 Reading s bands file... 
 WARNING: File for orbital character not found (s.dat). S character will be 1 for all bands. 
 Reading p bands file... 
 WARNING: File for orbital character not found (p_even.dat/p_odd.dat). P character will be 1 for all bands. 
 pdos: [ 56.02]
 Size(pdos): 1
 # ------------------------------------------------ # 
 Moving into output directory:
  /home/zhou/CRC/CRC/sky_test/Spfunctions
 Starting time (elaps, cpu): 5.006790e-06 2.000000e-06
 ### Calculation of exponential A...  
 Finding zeros in real parts...
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  8 0 0.892090749186 -0.0230405635179
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  15 0 0.655622735043 -0.0110815147929
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  20 0 0.356100742213 -0.00303214274354
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  21 0 1.06891927178 -0.0335603888166
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  25 0 1.01824091803 -0.0285156885246
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  27 0 0.919526772069 -0.0225254841897
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  28 0 1.59655792208 -0.0729534467532
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  29 0 1.70560319688 -0.0800293586745
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  35 0 0.277674156707 -0.00226940703851
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  36 0 1.00986644951 -0.0298910729642
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  42 0 0.898132431012 -0.0218574073587
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  46 0 0.737615402906 -0.0134732178336
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  47 0 1.42068812216 -0.0579794574399
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  50 0 0.680424848085 -0.0110964340159
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  51 0 1.48776840391 -0.060647132899
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  54 0 2.17733957447 -0.12552098646
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  61 0 0.168526604527 -0.00140085845539
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  65 0 0.951631663405 -0.0263540195695
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  66 0 0.778527078135 -0.0162697347341
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  67 0 0.555432346332 -0.00727432015863
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  68 0 0.431465116279 -0.00415756923588
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  69 0 1.24625895765 -0.0460401114007
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  70 0 1.25760464146 -0.0443110384615
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  71 0 1.21661147906 -0.0408371688482
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  72 0 1.88880205692 -0.0984309417853
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  76 0 0.676839339934 -0.0110677491749
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  77 0 1.36247532164 -0.053575502924
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  80 0 0.559074506949 -0.00676717498345
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  81 0 1.37390872964 -0.0517994814332
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  83 0 1.33298249017 -0.0485099279161
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  84 0 2.00422841012 -0.108746567164
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  92 0 0.426645693431 -0.00427088394161
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  95 0 1.12825950553 -0.0377080169161
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  96 0 1.02077901575 -0.0289182401575
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  97 0 0.863901156373 -0.0199901990802
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  98 0 0.807495567282 -0.0173472453826
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  99 0 1.53943569291 -0.068585597918
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  100 0 1.6100210691 -0.0711249595828
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  101 0 2.2962396401 -0.137758997429
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  102 0 0.49898702452 -0.00525599310802
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  103 0 1.27805531025 -0.0447641495754
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  104 0 1.94683968791 -0.102864635891
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  106 0 2.0505053886 -0.110299103627
 WARNING: Plasmarons! 
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  112 0 0.742706354029 -0.0142465898283
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  113 0 0.564832283256 -0.00760790006618
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  114 0 0.504128275862 -0.00580699204244
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  115 0 1.42296460039 -0.0585076530214
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  116 0 1.38079050228 -0.0527925570776
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  117 0 1.28796214519 -0.0456306651406
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  118 0 1.949515 -0.103979173377
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  119 0 2.06252967742 -0.11179883871
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  120 0 2.75923299363 -0.185719452229
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  123 0 0.371701551724 -0.00310167844828
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  124 0 0.297140638298 -0.00231928510638
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  125 0 1.17121272251 -0.0379192068063
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  126 0 1.0577533945 -0.0304501009174
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  127 0 1.83354127355 -0.0937429187784
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  128 0 1.85454983095 -0.0915366918075
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  129 0 1.81763 -0.0873881883117
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  130 0 2.47446873874 -0.15533009009
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  131 0 0.200613333333 -0.00148508433333
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  132 0 0.940127757256 -0.0241176609499
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  133 0 1.70928735677 -0.0782606269531
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  134 0 1.65676389831 -0.0736031610169
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  135 0 2.35864690231 -0.143219517995
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  136 0 2.43638779137 -0.146907920155
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  137 0 3.11352653087 -0.225892896244
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  138 0 1.60121629243 -0.0690036866841
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  139 0 2.35201608247 -0.136392770619
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  140 0 2.99913384615 -0.213355846154
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  141 0 3.11061767471 -0.220714517154
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  142 0 3.08534548673 -0.215829709229
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  143 0 3.75012385742 -0.304836441757
 WARNING: im(Sigma(eps_k)) <= 0 !!! ik ib eps_k im(Sigma(eps_k)) =  144 0 4.46446643533 -0.427677444795
 Test imeqp: [[  4.62824292e-01]
 [  4.41602621e-01]
 [  3.82311970e-01]
 [  2.94999140e-01]
 [  1.98035988e-01]
 [  1.05157005e-01]
 [  3.36324129e-02]
 [  2.66028025e-04]
 [ -2.30405635e-02]
 [  4.00639982e-01]
 [  3.28468034e-01]
 [  2.37266654e-01]
 [  1.43632662e-01]
 [  6.21579742e-02]
 [  9.18131954e-03]
 [ -1.10815148e-02]
 [  2.50979336e-01]
 [  1.64142459e-01]
 [  8.26484399e-02]
 [  2.24209822e-02]
 [ -3.03214274e-03]
 [ -3.35603888e-02]
 [  8.99291223e-02]
 [  3.00256700e-02]
 [  5.41971898e-05]
 [ -2.85156885e-02]
 [  1.65645026e-03]
 [ -2.25254842e-02]
 [ -7.29534468e-02]
 [ -8.00293587e-02]
 [  3.45572624e-01]
 [  2.64843933e-01]
 [  1.74580207e-01]
 [  8.96250924e-02]
 [  2.59653958e-02]
 [ -2.26940704e-03]
 [ -2.98910730e-02]
 [  4.20793739e-01]
 [  1.86816308e-01]
 [  1.05827108e-01]
 [  3.90378640e-02]
 [  2.63832243e-03]
 [ -2.18574074e-02]
 [  3.62713142e-01]
 [  4.41154064e-02]
 [  5.34585927e-03]
 [ -1.34732178e-02]
 [ -5.79794574e-02]
 [  2.80238571e-01]
 [  2.95364958e-01]
 [ -1.10964340e-02]
 [ -6.06471329e-02]
 [  1.86360446e-01]
 [  2.11453885e-01]
 [ -1.25520986e-01]
 [  9.75754421e-02]
 [  1.23987753e-01]
 [  1.33721926e-01]
 [  2.99012723e-02]
 [  4.93810461e-02]
 [  6.20270141e-02]
 [ -1.40085846e-03]
 [  5.34210335e-03]
 [  1.18965365e-02]
 [  1.51855031e-02]
 [ -2.63540196e-02]
 [ -1.62697347e-02]
 [ -7.27432016e-03]
 [ -4.15756924e-03]
 [ -4.60401114e-02]
 [ -4.43110385e-02]
 [ -4.08371688e-02]
 [ -9.84309418e-02]
 [  1.14636048e-01]
 [  4.99725137e-02]
 [  6.95753257e-03]
 [ -1.10677492e-02]
 [ -5.35755029e-02]
 [  3.10732995e-01]
 [  9.12683184e-03]
 [ -6.76717498e-03]
 [ -5.17994814e-02]
 [  2.37041833e-01]
 [ -4.85099279e-02]
 [ -1.08746567e-01]
 [  1.53523678e-01]
 [  1.64014907e-01]
 [  7.58900906e-02]
 [  8.99250297e-02]
 [  1.87925759e-02]
 [  2.98235312e-02]
 [  3.37846195e-02]
 [ -4.27088394e-03]
 [  4.00327525e-05]
 [  2.61962008e-03]
 [ -3.77080169e-02]
 [ -2.89182402e-02]
 [ -1.99901991e-02]
 [ -1.73472454e-02]
 [ -6.85855979e-02]
 [ -7.11249596e-02]
 [ -1.37758997e-01]
 [ -5.25599311e-03]
 [ -4.47641496e-02]
 [ -1.02864636e-01]
 [  1.74321309e-01]
 [ -1.10299104e-01]
 [  1.05538909e-01]
 [  4.35111117e-02]
 [  4.91033146e-02]
 [  5.16239312e-03]
 [  8.89866852e-03]
 [ -1.42465898e-02]
 [ -7.60790007e-03]
 [ -5.80699204e-03]
 [ -5.85076530e-02]
 [ -5.27925571e-02]
 [ -4.56306651e-02]
 [ -1.03979173e-01]
 [ -1.11798839e-01]
 [ -1.85719452e-01]
 [  5.52239063e-02]
 [  1.40995668e-02]
 [ -3.10167845e-03]
 [ -2.31928511e-03]
 [ -3.79192068e-02]
 [ -3.04501009e-02]
 [ -9.37429188e-02]
 [ -9.15366918e-02]
 [ -8.73881883e-02]
 [ -1.55330090e-01]
 [ -1.48508433e-03]
 [ -2.41176609e-02]
 [ -7.82606270e-02]
 [ -7.36031610e-02]
 [ -1.43219518e-01]
 [ -1.46907920e-01]
 [ -2.25892896e-01]
 [ -6.90036867e-02]
 [ -1.36392771e-01]
 [ -2.13355846e-01]
 [ -2.20714517e-01]
 [ -2.15829709e-01]
 [ -3.04836442e-01]
 [ -4.27677445e-01]]
 ### ================== ###
 ###    Multipole fit   ###
 Number of poles: 1
 ik, ib 0 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.0843 1181 0.100071440678
 Number of poles (nbin): 1
 Total integral: 20.675918861
 Total integral / nbin: 20.675918861
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.0843
(OK)
 Check if sum of gi gives the original total integral (origint):  20.7391312532 20.675918861
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 20.675918861
 \sum_j^N\lambda_j = 20.7391312532
 ik, ib 1 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.0843 1181 0.100071440678
 Number of poles (nbin): 1
 Total integral: 20.5135426613
 Total integral / nbin: 20.5135426613
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.0843
(OK)
 Check if sum of gi gives the original total integral (origint):  20.5952250695 20.5135426613
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 20.5135426613
 \sum_j^N\lambda_j = 20.5952250695
 ik, ib 2 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.2845 1183 0.100071489002
 Number of poles (nbin): 1
 Total integral: 20.0443181111
 Total integral / nbin: 20.0443181111
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.2845
(OK)
 Check if sum of gi gives the original total integral (origint):  20.1441582139 20.0443181111
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 20.0443181111
 \sum_j^N\lambda_j = 20.1441582139
 ik, ib 3 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.5847 1186 0.100071476793
 Number of poles (nbin): 1
 Total integral: 19.2161340256
 Total integral / nbin: 19.2161340256
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.5847
(OK)
 Check if sum of gi gives the original total integral (origint):  19.3560683478 19.2161340256
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 19.2161340256
 \sum_j^N\lambda_j = 19.3560683478
 ik, ib 4 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.985 1190 0.100071488646
 Number of poles (nbin): 1
 Total integral: 17.9635053354
 Total integral / nbin: 17.9635053354
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.985
(OK)
 Check if sum of gi gives the original total integral (origint):  18.1058025707 17.9635053354
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.9635053354
 \sum_j^N\lambda_j = 18.1058025707
 ik, ib 5 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.58542 1196 0.100071481172
 Number of poles (nbin): 1
 Total integral: 16.1609018807
 Total integral / nbin: 16.1609018807
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.58542
(OK)
 Check if sum of gi gives the original total integral (origint):  16.3779612065 16.1609018807
WARNING: the difference is 0.0132531346934
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.1609018807
 \sum_j^N\lambda_j = 16.3779612065
 ik, ib 6 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.28592 1203 0.100071480865
 Number of poles (nbin): 1
 Total integral: 13.5106223559
 Total integral / nbin: 13.5106223559
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.28592
(OK)
 Check if sum of gi gives the original total integral (origint):  13.6316899713 13.5106223559
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.5106223559
 \sum_j^N\lambda_j = 13.6316899713
 ik, ib 7 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 121.1866 1212 0.100071511148
 Number of poles (nbin): 1
 Total integral: 9.76784550927
 Total integral / nbin: 9.76784550927
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  121.1866
(OK)
 Check if sum of gi gives the original total integral (origint):  9.85265074725 9.76784550927
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.76784550927
 \sum_j^N\lambda_j = 9.85265074725
 ik, ib 8 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.7127 178 0.100071751412
 Number of poles (nbin): 1
 Total integral: 23.1143261437
 Total integral / nbin: 23.1143261437
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.759935881735 19.3947083665
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.7127
(OK)
 Check if sum of gi gives the original total integral (origint):  23.1515504909 23.1143261437
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.1143261437
 \sum_j^N\lambda_j = 23.1515504909
 ik, ib 9 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.2845 1183 0.100071489002
 Number of poles (nbin): 1
 Total integral: 20.21120927
 Total integral / nbin: 20.21120927
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.2845
(OK)
 Check if sum of gi gives the original total integral (origint):  20.3098864635 20.21120927
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 20.21120927
 \sum_j^N\lambda_j = 20.3098864635
 ik, ib 10 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.4846 1185 0.100071452703
 Number of poles (nbin): 1
 Total integral: 19.5562294955
 Total integral / nbin: 19.5562294955
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.4846
(OK)
 Check if sum of gi gives the original total integral (origint):  19.674743326 19.5562294955
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 19.5562294955
 \sum_j^N\lambda_j = 19.674743326
 ik, ib 11 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.8849 1189 0.100071464646
 Number of poles (nbin): 1
 Total integral: 18.5217456177
 Total integral / nbin: 18.5217456177
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.8849
(OK)
 Check if sum of gi gives the original total integral (origint):  18.6646676287 18.5217456177
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 18.5217456177
 \sum_j^N\lambda_j = 18.6646676287
 ik, ib 12 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.2852 1193 0.10007147651
 Number of poles (nbin): 1
 Total integral: 16.9963109119
 Total integral / nbin: 16.9963109119
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.2852
(OK)
 Check if sum of gi gives the original total integral (origint):  17.2202367989 16.9963109119
WARNING: the difference is 0.0130036473736
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.9963109119
 \sum_j^N\lambda_j = 17.2202367989
 ik, ib 13 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.985704 1200 0.100071479566
 Number of poles (nbin): 1
 Total integral: 14.8063353592
 Total integral / nbin: 14.8063353592
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.985704
(OK)
 Check if sum of gi gives the original total integral (origint):  14.9400855035 14.8063353592
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.8063353592
 \sum_j^N\lambda_j = 14.9400855035
 ik, ib 14 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.6862 1207 0.100071475954
 Number of poles (nbin): 1
 Total integral: 11.4338921941
 Total integral / nbin: 11.4338921941
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.6862
(OK)
 Check if sum of gi gives the original total integral (origint):  11.5437295258 11.4338921941
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.4338921941
 \sum_j^N\lambda_j = 11.5437295258
 ik, ib 15 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.9128 180 0.10007150838
 Number of poles (nbin): 1
 Total integral: 22.2831976444
 Total integral / nbin: 22.2831976444
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.731334493626 19.6668440078
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.9128
(OK)
 Check if sum of gi gives the original total integral (origint):  22.592828605 22.2831976444
WARNING: the difference is 0.0137048337809
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.2831976444
 \sum_j^N\lambda_j = 22.592828605
 ik, ib 16 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.7848 1188 0.100071440607
 Number of poles (nbin): 1
 Total integral: 18.6978996553
 Total integral / nbin: 18.6978996553
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.7848
(OK)
 Check if sum of gi gives the original total integral (origint):  18.8403816864 18.6978996553
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 18.6978996553
 \sum_j^N\lambda_j = 18.8403816864
 ik, ib 17 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.18513 1192 0.10007147775
 Number of poles (nbin): 1
 Total integral: 17.4004601962
 Total integral / nbin: 17.4004601962
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.18513
(OK)
 Check if sum of gi gives the original total integral (origint):  17.6268967405 17.4004601962
WARNING: the difference is 0.0128460810567
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.4004601962
 \sum_j^N\lambda_j = 17.6268967405
 ik, ib 18 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.78556 1198 0.100071478697
 Number of poles (nbin): 1
 Total integral: 15.5267914795
 Total integral / nbin: 15.5267914795
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.78556
(OK)
 Check if sum of gi gives the original total integral (origint):  15.6647173215 15.5267914795
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.5267914795
 \sum_j^N\lambda_j = 15.6647173215
 ik, ib 19 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.38599 1204 0.100071479634
 Number of poles (nbin): 1
 Total integral: 12.7078964924
 Total integral / nbin: 12.7078964924
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.38599
(OK)
 Check if sum of gi gives the original total integral (origint):  12.8252482885 12.7078964924
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.7078964924
 \sum_j^N\lambda_j = 12.8252482885
 ik, ib 20 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.213 183 0.100071428571
 Number of poles (nbin): 1
 Total integral: 21.2679199209
 Total integral / nbin: 21.2679199209
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.682617228201 20.0248795854
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.213
(OK)
 Check if sum of gi gives the original total integral (origint):  21.4717298943 21.2679199209
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.2679199209
 \sum_j^N\lambda_j = 21.4717298943
 ik, ib 21 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.5125 176 0.100071428571
 Number of poles (nbin): 1
 Total integral: 23.4599172063
 Total integral / nbin: 23.4599172063
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.784619957804 19.2498925245
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.5125
(OK)
 Check if sum of gi gives the original total integral (origint):  23.725071881 23.4599172063
WARNING: the difference is 0.0111761378851
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.4599172063
 \sum_j^N\lambda_j = 23.725071881
 ik, ib 22 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.68549 1197 0.100071479933
 Number of poles (nbin): 1
 Total integral: 15.7575793064
 Total integral / nbin: 15.7575793064
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.68549
(OK)
 Check if sum of gi gives the original total integral (origint):  15.9714160412 15.7575793064
WARNING: the difference is 0.0133887148331
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.7575793064
 \sum_j^N\lambda_j = 15.9714160412
 ik, ib 23 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.28592 1203 0.100071480865
 Number of poles (nbin): 1
 Total integral: 13.3342185777
 Total integral / nbin: 13.3342185777
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.28592
(OK)
 Check if sum of gi gives the original total integral (origint):  13.4605529365 13.3342185777
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.3342185777
 \sum_j^N\lambda_j = 13.4605529365
 ik, ib 24 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 121.2866 1213 0.100071452145
 Number of poles (nbin): 1
 Total integral: 9.91726816988
 Total integral / nbin: 9.91726816988
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  121.2866
(OK)
 Check if sum of gi gives the original total integral (origint):  10.0038447939 9.91726816988
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.91726816988
 \sum_j^N\lambda_j = 10.0038447939
 ik, ib 25 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.6126 177 0.100071590909
 Number of poles (nbin): 1
 Total integral: 23.0861340757
 Total integral / nbin: 23.0861340757
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.769563857141 19.3457548174
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.6126
(OK)
 Check if sum of gi gives the original total integral (origint):  23.3856916527 23.0861340757
WARNING: the difference is 0.0128094384139
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.0861340757
 \sum_j^N\lambda_j = 23.3856916527
 ik, ib 26 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 121.0865 1211 0.100071487603
 Number of poles (nbin): 1
 Total integral: 10.1684353507
 Total integral / nbin: 10.1684353507
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  121.0865
(OK)
 Check if sum of gi gives the original total integral (origint):  10.2698538746 10.1684353507
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.1684353507
 \sum_j^N\lambda_j = 10.2698538746
 ik, ib 27 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.7127 178 0.100071751412
 Number of poles (nbin): 1
 Total integral: 22.7625439537
 Total integral / nbin: 22.7625439537
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.754389173811 19.4511963273
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.7127
(OK)
 Check if sum of gi gives the original total integral (origint):  23.0495070431 22.7625439537
WARNING: the difference is 0.012449857991
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.7625439537
 \sum_j^N\lambda_j = 23.0495070431
 ik, ib 28 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.0122 171 0.100071764706
 Number of poles (nbin): 1
 Total integral: 24.0708601984
 Total integral / nbin: 24.0708601984
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.0122
(OK)
 Check if sum of gi gives the original total integral (origint):  24.4589325413 24.0708601984
WARNING: the difference is 0.0158662828926
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.0708601984
 \sum_j^N\lambda_j = 24.4589325413
 ik, ib 29 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.9121 170 0.100071597633
 Number of poles (nbin): 1
 Total integral: 24.0427113324
 Total integral / nbin: 24.0427113324
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.9121
(OK)
 Check if sum of gi gives the original total integral (origint):  24.4312473089 24.0427113324
WARNING: the difference is 0.0159032394692
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.0427113324
 \sum_j^N\lambda_j = 24.4312473089
 ik, ib 30 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.3846 1184 0.100071513102
 Number of poles (nbin): 1
 Total integral: 19.7186996795
 Total integral / nbin: 19.7186996795
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.3846
(OK)
 Check if sum of gi gives the original total integral (origint):  19.8353496522 19.7186996795
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 19.7186996795
 \sum_j^N\lambda_j = 19.8353496522
 ik, ib 31 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.6848 1187 0.100071500843
 Number of poles (nbin): 1
 Total integral: 18.8730946925
 Total integral / nbin: 18.8730946925
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.6848
(OK)
 Check if sum of gi gives the original total integral (origint):  19.0144430578 18.8730946925
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 18.8730946925
 \sum_j^N\lambda_j = 19.0144430578
 ik, ib 32 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.18513 1192 0.10007147775
 Number of poles (nbin): 1
 Total integral: 17.5999638644
 Total integral / nbin: 17.5999638644
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.18513
(OK)
 Check if sum of gi gives the original total integral (origint):  17.84551823 17.5999638644
WARNING: the difference is 0.0137600019498
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.5999638644
 \sum_j^N\lambda_j = 17.84551823
 ik, ib 33 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.68549 1197 0.100071479933
 Number of poles (nbin): 1
 Total integral: 15.7499040482
 Total integral / nbin: 15.7499040482
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.68549
(OK)
 Check if sum of gi gives the original total integral (origint):  15.8880392405 15.7499040482
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.7499040482
 \sum_j^N\lambda_j = 15.8880392405
 ik, ib 34 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.38599 1204 0.100071479634
 Number of poles (nbin): 1
 Total integral: 12.9979513843
 Total integral / nbin: 12.9979513843
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.38599
(OK)
 Check if sum of gi gives the original total integral (origint):  13.1179501196 12.9979513843
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.9979513843
 \sum_j^N\lambda_j = 13.1179501196
 ik, ib 35 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.3131 184 0.100071584699
 Number of poles (nbin): 1
 Total integral: 21.0687388617
 Total integral / nbin: 21.0687388617
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.3131
(OK)
 Check if sum of gi gives the original total integral (origint):  21.3932446412 21.0687388617
WARNING: the difference is 0.0151686097613
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.0687388617
 \sum_j^N\lambda_j = 21.3932446412
 ik, ib 36 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.6126 177 0.100071590909
 Number of poles (nbin): 1
 Total integral: 23.3604947219
 Total integral / nbin: 23.3604947219
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.777146158677 19.2936426176
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.6126
(OK)
 Check if sum of gi gives the original total integral (origint):  23.5524890963 23.3604947219
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.3604947219
 \sum_j^N\lambda_j = 23.5524890963
 ik, ib 37 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.1844 1182 0.10007146486
 Number of poles (nbin): 1
 Total integral: 20.3631315748
 Total integral / nbin: 20.3631315748
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.1844
(OK)
 Check if sum of gi gives the original total integral (origint):  20.4590401559 20.3631315748
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 20.3631315748
 \sum_j^N\lambda_j = 20.4590401559
 ik, ib 38 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.08506 1191 0.100071478992
 Number of poles (nbin): 1
 Total integral: 17.7903371014
 Total integral / nbin: 17.7903371014
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.08506
(OK)
 Check if sum of gi gives the original total integral (origint):  17.9322509984 17.7903371014
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.7903371014
 \sum_j^N\lambda_j = 17.9322509984
 ik, ib 39 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.58542 1196 0.100071481172
 Number of poles (nbin): 1
 Total integral: 16.201043145
 Total integral / nbin: 16.201043145
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.58542
(OK)
 Check if sum of gi gives the original total integral (origint):  16.4192655907 16.201043145
WARNING: the difference is 0.0132906337668
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.201043145
 \sum_j^N\lambda_j = 16.4192655907
 ik, ib 40 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.18585 1202 0.100071482098
 Number of poles (nbin): 1
 Total integral: 13.8907849953
 Total integral / nbin: 13.8907849953
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.18585
(OK)
 Check if sum of gi gives the original total integral (origint):  14.0105261627 13.8907849953
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.8907849953
 \sum_j^N\lambda_j = 14.0105261627
 ik, ib 41 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.98642 1210 0.100071480562
 Number of poles (nbin): 1
 Total integral: 10.4218460231
 Total integral / nbin: 10.4218460231
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.98642
(OK)
 Check if sum of gi gives the original total integral (origint):  10.5252899791 10.4218460231
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.4218460231
 \sum_j^N\lambda_j = 10.5252899791
 ik, ib 42 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.7127 178 0.100071751412
 Number of poles (nbin): 1
 Total integral: 22.8187216924
 Total integral / nbin: 22.8187216924
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.756307768388 19.452591897
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.7127
(OK)
 Check if sum of gi gives the original total integral (origint):  23.1097854726 22.8187216924
WARNING: the difference is 0.0125948283053
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.8187216924
 \sum_j^N\lambda_j = 23.1097854726
 ik, ib 43 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.3846 1184 0.100071513102
 Number of poles (nbin): 1
 Total integral: 19.8862709035
 Total integral / nbin: 19.8862709035
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.3846
(OK)
 Check if sum of gi gives the original total integral (origint):  20.0031588815 19.8862709035
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 19.8862709035
 \sum_j^N\lambda_j = 20.0031588815
 ik, ib 44 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.085776 1201 0.10007148
 Number of poles (nbin): 1
 Total integral: 14.1602451877
 Total integral / nbin: 14.1602451877
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.085776
(OK)
 Check if sum of gi gives the original total integral (origint):  14.2775686419 14.1602451877
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.1602451877
 \sum_j^N\lambda_j = 14.2775686419
 ik, ib 45 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.78628 1208 0.100071483016
 Number of poles (nbin): 1
 Total integral: 11.0836730174
 Total integral / nbin: 11.0836730174
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.78628
(OK)
 Check if sum of gi gives the original total integral (origint):  11.1917330716 11.0836730174
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.0836730174
 \sum_j^N\lambda_j = 11.1917330716
 ik, ib 46 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.9128 180 0.10007150838
 Number of poles (nbin): 1
 Total integral: 22.2776529716
 Total integral / nbin: 22.2776529716
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.723069690979 19.645665715
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.9128
(OK)
 Check if sum of gi gives the original total integral (origint):  22.3134531069 22.2776529716
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.2776529716
 \sum_j^N\lambda_j = 22.3134531069
 ik, ib 47 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.2123 173 0.100071511628
 Number of poles (nbin): 1
 Total integral: 23.899138971
 Total integral / nbin: 23.899138971
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.2123
(OK)
 Check if sum of gi gives the original total integral (origint):  24.2854699737 23.899138971
WARNING: the difference is 0.0159079072035
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.899138971
 \sum_j^N\lambda_j = 24.2854699737
 ik, ib 48 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.6848 1187 0.100071500843
 Number of poles (nbin): 1
 Total integral: 19.0458055537
 Total integral / nbin: 19.0458055537
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.6848
(OK)
 Check if sum of gi gives the original total integral (origint):  19.1875508155 19.0458055537
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 19.0458055537
 \sum_j^N\lambda_j = 19.1875508155
 ik, ib 49 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.5847 1186 0.100071476793
 Number of poles (nbin): 1
 Total integral: 19.2123477314
 Total integral / nbin: 19.2123477314
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.5847
(OK)
 Check if sum of gi gives the original total integral (origint):  19.3527823357 19.2123477314
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 19.2123477314
 \sum_j^N\lambda_j = 19.3527823357
 ik, ib 50 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.9128 180 0.10007150838
 Number of poles (nbin): 1
 Total integral: 22.096106266
 Total integral / nbin: 22.096106266
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.723765477043 19.69848021
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.9128
(OK)
 Check if sum of gi gives the original total integral (origint):  22.3949687789 22.096106266
WARNING: the difference is 0.0133450738773
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.096106266
 \sum_j^N\lambda_j = 22.3949687789
 ik, ib 51 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.1122 172 0.100071345029
 Number of poles (nbin): 1
 Total integral: 23.8014337205
 Total integral / nbin: 23.8014337205
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.1122
(OK)
 Check if sum of gi gives the original total integral (origint):  24.1785385423 23.8014337205
WARNING: the difference is 0.0155966755857
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.8014337205
 \sum_j^N\lambda_j = 24.1785385423
 ik, ib 52 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.08506 1191 0.100071478992
 Number of poles (nbin): 1
 Total integral: 17.7754220619
 Total integral / nbin: 17.7754220619
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.08506
(OK)
 Check if sum of gi gives the original total integral (origint):  17.9185019628 17.7754220619
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.7754220619
 \sum_j^N\lambda_j = 17.9185019628
 ik, ib 53 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.985 1190 0.100071488646
 Number of poles (nbin): 1
 Total integral: 18.1512369935
 Total integral / nbin: 18.1512369935
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.985
(OK)
 Check if sum of gi gives the original total integral (origint):  18.2949409664 18.1512369935
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 18.1512369935
 \sum_j^N\lambda_j = 18.2949409664
 ik, ib 54 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.4117 165 0.100071341463
 Number of poles (nbin): 1
 Total integral: 24.3885434109
 Total integral / nbin: 24.3885434109
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.4117
(OK)
 Check if sum of gi gives the original total integral (origint):  24.7769255085 24.3885434109
WARNING: the difference is 0.0156751529733
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.3885434109
 \sum_j^N\lambda_j = 24.7769255085
 ik, ib 55 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.58542 1196 0.100071481172
 Number of poles (nbin): 1
 Total integral: 15.9442004681
 Total integral / nbin: 15.9442004681
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.58542
(OK)
 Check if sum of gi gives the original total integral (origint):  16.0815973207 15.9442004681
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.9442004681
 \sum_j^N\lambda_j = 16.0815973207
 ik, ib 56 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.48535 1195 0.100071482412
 Number of poles (nbin): 1
 Total integral: 16.5891786317
 Total integral / nbin: 16.5891786317
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.48535
(OK)
 Check if sum of gi gives the original total integral (origint):  16.8097977444 16.5891786317
WARNING: the difference is 0.0131244358837
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.5891786317
 \sum_j^N\lambda_j = 16.8097977444
 ik, ib 57 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.38528 1194 0.100071483655
 Number of poles (nbin): 1
 Total integral: 16.7955839978
 Total integral / nbin: 16.7955839978
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.38528
(OK)
 Check if sum of gi gives the original total integral (origint):  17.0156720983 16.7955839978
WARNING: the difference is 0.0129344347507
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.7955839978
 \sum_j^N\lambda_j = 17.0156720983
 ik, ib 58 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.28592 1203 0.100071480865
 Number of poles (nbin): 1
 Total integral: 13.2303059941
 Total integral / nbin: 13.2303059941
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.28592
(OK)
 Check if sum of gi gives the original total integral (origint):  13.3516997616 13.2303059941
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.2303059941
 \sum_j^N\lambda_j = 13.3516997616
 ik, ib 59 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.085776 1201 0.10007148
 Number of poles (nbin): 1
 Total integral: 14.3225071745
 Total integral / nbin: 14.3225071745
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.085776
(OK)
 Check if sum of gi gives the original total integral (origint):  14.454268927 14.3225071745
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.3225071745
 \sum_j^N\lambda_j = 14.454268927
 ik, ib 60 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.985704 1200 0.100071479566
 Number of poles (nbin): 1
 Total integral: 14.826986048
 Total integral / nbin: 14.826986048
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.985704
(OK)
 Check if sum of gi gives the original total integral (origint):  14.9615747106 14.826986048
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.826986048
 \sum_j^N\lambda_j = 14.9615747106
 ik, ib 61 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.4132 185 0.10007173913
 Number of poles (nbin): 1
 Total integral: 20.9033996694
 Total integral / nbin: 20.9033996694
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.660615289357 20.2259802342
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.4132
(OK)
 Check if sum of gi gives the original total integral (origint):  20.9883392959 20.9033996694
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 20.9033996694
 \sum_j^N\lambda_j = 20.9883392959
 ik, ib 62 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.78628 1208 0.100071483016
 Number of poles (nbin): 1
 Total integral: 10.8532810223
 Total integral / nbin: 10.8532810223
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.78628
(OK)
 Check if sum of gi gives the original total integral (origint):  10.9587904987 10.8532810223
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.8532810223
 \sum_j^N\lambda_j = 10.9587904987
 ik, ib 63 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.58613 1206 0.100071477178
 Number of poles (nbin): 1
 Total integral: 11.8289986214
 Total integral / nbin: 11.8289986214
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.58613
(OK)
 Check if sum of gi gives the original total integral (origint):  11.9416384302 11.8289986214
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.8289986214
 \sum_j^N\lambda_j = 11.9416384302
 ik, ib 64 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.58613 1206 0.100071477178
 Number of poles (nbin): 1
 Total integral: 12.1592702772
 Total integral / nbin: 12.1592702772
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.58613
(OK)
 Check if sum of gi gives the original total integral (origint):  12.2744606494 12.1592702772
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.1592702772
 \sum_j^N\lambda_j = 12.2744606494
 ik, ib 65 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.7127 178 0.100071751412
 Number of poles (nbin): 1
 Total integral: 23.2562407043
 Total integral / nbin: 23.2562407043
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.776360301868 19.3250093817
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.7127
(OK)
 Check if sum of gi gives the original total integral (origint):  23.5669245103 23.2562407043
WARNING: the difference is 0.0131830441382
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.2562407043
 \sum_j^N\lambda_j = 23.5669245103
 ik, ib 66 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.8127 179 0.100071348315
 Number of poles (nbin): 1
 Total integral: 22.600462766
 Total integral / nbin: 22.600462766
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.744788241356 19.5570872294
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.8127
(OK)
 Check if sum of gi gives the original total integral (origint):  22.8800443151 22.600462766
WARNING: the difference is 0.0122194496297
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.600462766
 \sum_j^N\lambda_j = 22.8800443151
 ik, ib 67 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.0129 181 0.100071666667
 Number of poles (nbin): 1
 Total integral: 21.8505916703
 Total integral / nbin: 21.8505916703
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.709067295234 19.8190172448
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.0129
(OK)
 Check if sum of gi gives the original total integral (origint):  22.0744274086 21.8505916703
WARNING: the difference is 0.0101400473073
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.8505916703
 \sum_j^N\lambda_j = 22.0744274086
 ik, ib 68 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.213 183 0.100071428571
 Number of poles (nbin): 1
 Total integral: 21.4050428502
 Total integral / nbin: 21.4050428502
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.691518222803 19.9681825454
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.213
(OK)
 Check if sum of gi gives the original total integral (origint):  21.6901244758 21.4050428502
WARNING: the difference is 0.0131433835694
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.4050428502
 \sum_j^N\lambda_j = 21.6901244758
 ik, ib 69 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.4124 175 0.100071264368
 Number of poles (nbin): 1
 Total integral: 23.7180869587
 Total integral / nbin: 23.7180869587
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.796031257483 19.1119803874
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.4124
(OK)
 Check if sum of gi gives the original total integral (origint):  23.8976771397 23.7180869587
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.7180869587
 \sum_j^N\lambda_j = 23.8976771397
 ik, ib 70 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.3124 174 0.100071676301
 Number of poles (nbin): 1
 Total integral: 23.5210923398
 Total integral / nbin: 23.5210923398
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.3124
(OK)
 Check if sum of gi gives the original total integral (origint):  23.8997513218 23.5210923398
WARNING: the difference is 0.0158436369029
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.5210923398
 \sum_j^N\lambda_j = 23.8997513218
 ik, ib 71 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.4124 175 0.100071264368
 Number of poles (nbin): 1
 Total integral: 23.4153152819
 Total integral / nbin: 23.4153152819
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.786573081529 19.1749481461
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.4124
(OK)
 Check if sum of gi gives the original total integral (origint):  23.691532538 23.4153152819
WARNING: the difference is 0.0116589020034
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.4153152819
 \sum_j^N\lambda_j = 23.691532538
 ik, ib 72 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.7119 168 0.100071257485
 Number of poles (nbin): 1
 Total integral: 24.2782538232
 Total integral / nbin: 24.2782538232
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.7119
(OK)
 Check if sum of gi gives the original total integral (origint):  24.6643107768 24.2782538232
WARNING: the difference is 0.0156524525279
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.2782538232
 \sum_j^N\lambda_j = 24.6643107768
 ik, ib 73 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.48535 1195 0.100071482412
 Number of poles (nbin): 1
 Total integral: 16.4157497593
 Total integral / nbin: 16.4157497593
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.48535
(OK)
 Check if sum of gi gives the original total integral (origint):  16.5395122638 16.4157497593
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.4157497593
 \sum_j^N\lambda_j = 16.5395122638
 ik, ib 74 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.085776 1201 0.10007148
 Number of poles (nbin): 1
 Total integral: 14.4092989498
 Total integral / nbin: 14.4092989498
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.085776
(OK)
 Check if sum of gi gives the original total integral (origint):  14.5416963116 14.4092989498
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.4092989498
 \sum_j^N\lambda_j = 14.5416963116
 ik, ib 75 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.78628 1208 0.100071483016
 Number of poles (nbin): 1
 Total integral: 11.3717930247
 Total integral / nbin: 11.3717930247
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.78628
(OK)
 Check if sum of gi gives the original total integral (origint):  11.4825110635 11.3717930247
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.3717930247
 \sum_j^N\lambda_j = 11.4825110635
 ik, ib 76 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.9128 180 0.10007150838
 Number of poles (nbin): 1
 Total integral: 22.10717269
 Total integral / nbin: 22.10717269
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.722821764187 19.7000458301
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.9128
(OK)
 Check if sum of gi gives the original total integral (origint):  22.3675457464 22.10717269
WARNING: the difference is 0.0116406627402
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.10717269
 \sum_j^N\lambda_j = 22.3675457464
 ik, ib 77 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.2123 173 0.100071511628
 Number of poles (nbin): 1
 Total integral: 23.8332113589
 Total integral / nbin: 23.8332113589
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.2123
(OK)
 Check if sum of gi gives the original total integral (origint):  24.2202575324 23.8332113589
WARNING: the difference is 0.0159802666396
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.8332113589
 \sum_j^N\lambda_j = 24.2202575324
 ik, ib 78 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.5847 1186 0.100071476793
 Number of poles (nbin): 1
 Total integral: 19.3876096587
 Total integral / nbin: 19.3876096587
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.5847
(OK)
 Check if sum of gi gives the original total integral (origint):  19.5279043493 19.3876096587
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 19.3876096587
 \sum_j^N\lambda_j = 19.5279043493
 ik, ib 79 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.6862 1207 0.100071475954
 Number of poles (nbin): 1
 Total integral: 11.6325585236
 Total integral / nbin: 11.6325585236
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.6862
(OK)
 Check if sum of gi gives the original total integral (origint):  11.7388803503 11.6325585236
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.6325585236
 \sum_j^N\lambda_j = 11.7388803503
 ik, ib 80 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.0129 181 0.100071666667
 Number of poles (nbin): 1
 Total integral: 21.787357938
 Total integral / nbin: 21.787357938
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.707137911271 19.8251297787
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.0129
(OK)
 Check if sum of gi gives the original total integral (origint):  22.0211521396 21.787357938
WARNING: the difference is 0.0106168015242
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.787357938
 \sum_j^N\lambda_j = 22.0211521396
 ik, ib 81 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.2123 173 0.100071511628
 Number of poles (nbin): 1
 Total integral: 23.6648539533
 Total integral / nbin: 23.6648539533
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.2123
(OK)
 Check if sum of gi gives the original total integral (origint):  24.0424516278 23.6648539533
WARNING: the difference is 0.0157054563454
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.6648539533
 \sum_j^N\lambda_j = 24.0424516278
 ik, ib 82 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 118.8849 1189 0.100071464646
 Number of poles (nbin): 1
 Total integral: 18.512488137
 Total integral / nbin: 18.512488137
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  118.8849
(OK)
 Check if sum of gi gives the original total integral (origint):  18.6517669189 18.512488137
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 18.512488137
 \sum_j^N\lambda_j = 18.6517669189
 ik, ib 83 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.3124 174 0.100071676301
 Number of poles (nbin): 1
 Total integral: 23.5814667138
 Total integral / nbin: 23.5814667138
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.3124
(OK)
 Check if sum of gi gives the original total integral (origint):  23.9602920235 23.5814667138
WARNING: the difference is 0.0158105464382
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.5814667138
 \sum_j^N\lambda_j = 23.9602920235
 ik, ib 84 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.6119 167 0.100071686747
 Number of poles (nbin): 1
 Total integral: 24.329158421
 Total integral / nbin: 24.329158421
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.6119
(OK)
 Check if sum of gi gives the original total integral (origint):  24.7071995965 24.329158421
WARNING: the difference is 0.0153008508303
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.329158421
 \sum_j^N\lambda_j = 24.7071995965
 ik, ib 85 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.2852 1193 0.10007147651
 Number of poles (nbin): 1
 Total integral: 17.1880122332
 Total integral / nbin: 17.1880122332
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.2852
(OK)
 Check if sum of gi gives the original total integral (origint):  17.4128517366 17.1880122332
WARNING: the difference is 0.0129122734613
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.1880122332
 \sum_j^N\lambda_j = 17.4128517366
 ik, ib 86 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.18513 1192 0.10007147775
 Number of poles (nbin): 1
 Total integral: 17.3785572874
 Total integral / nbin: 17.3785572874
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.18513
(OK)
 Check if sum of gi gives the original total integral (origint):  17.6033311025 17.3785572874
WARNING: the difference is 0.0127688227708
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.3785572874
 \sum_j^N\lambda_j = 17.6033311025
 ik, ib 87 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.78556 1198 0.100071478697
 Number of poles (nbin): 1
 Total integral: 15.2713957104
 Total integral / nbin: 15.2713957104
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.78556
(OK)
 Check if sum of gi gives the original total integral (origint):  15.4076799695 15.2713957104
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.2713957104
 \sum_j^N\lambda_j = 15.4076799695
 ik, ib 88 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.68549 1197 0.100071479933
 Number of poles (nbin): 1
 Total integral: 15.7176381633
 Total integral / nbin: 15.7176381633
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.68549
(OK)
 Check if sum of gi gives the original total integral (origint):  15.8546949703 15.7176381633
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.7176381633
 \sum_j^N\lambda_j = 15.8546949703
 ik, ib 89 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.48606 1205 0.100071478405
 Number of poles (nbin): 1
 Total integral: 12.3918412837
 Total integral / nbin: 12.3918412837
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.48606
(OK)
 Check if sum of gi gives the original total integral (origint):  12.5084880692 12.3918412837
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.3918412837
 \sum_j^N\lambda_j = 12.5084880692
 ik, ib 90 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.28592 1203 0.100071480865
 Number of poles (nbin): 1
 Total integral: 13.2753062531
 Total integral / nbin: 13.2753062531
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.28592
(OK)
 Check if sum of gi gives the original total integral (origint):  13.3969049466 13.2753062531
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.2753062531
 \sum_j^N\lambda_j = 13.3969049466
 ik, ib 91 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.28592 1203 0.100071480865
 Number of poles (nbin): 1
 Total integral: 13.5592010185
 Total integral / nbin: 13.5592010185
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.28592
(OK)
 Check if sum of gi gives the original total integral (origint):  13.681210681 13.5592010185
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.5592010185
 \sum_j^N\lambda_j = 13.681210681
 ik, ib 92 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.213 183 0.100071428571
 Number of poles (nbin): 1
 Total integral: 21.478419692
 Total integral / nbin: 21.478419692
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.693151152355 19.9437713065
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.213
(OK)
 Check if sum of gi gives the original total integral (origint):  21.7147639194 21.478419692
WARNING: the difference is 0.0108840339396
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.478419692
 \sum_j^N\lambda_j = 21.7147639194
 ik, ib 93 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 121.2866 1213 0.100071452145
 Number of poles (nbin): 1
 Total integral: 9.85997697916
 Total integral / nbin: 9.85997697916
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  121.2866
(OK)
 Check if sum of gi gives the original total integral (origint):  9.95681465516 9.85997697916
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.85997697916
 \sum_j^N\lambda_j = 9.95681465516
 ik, ib 94 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.98642 1210 0.100071480562
 Number of poles (nbin): 1
 Total integral: 10.3570675344
 Total integral / nbin: 10.3570675344
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.98642
(OK)
 Check if sum of gi gives the original total integral (origint):  10.459666805 10.3570675344
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.3570675344
 \sum_j^N\lambda_j = 10.459666805
 ik, ib 95 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.5125 176 0.100071428571
 Number of poles (nbin): 1
 Total integral: 23.560322768
 Total integral / nbin: 23.560322768
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.792658973805 19.1945089395
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.5125
(OK)
 Check if sum of gi gives the original total integral (origint):  23.8991944941 23.560322768
WARNING: the difference is 0.0141792111941
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.560322768
 \sum_j^N\lambda_j = 23.8991944941
 ik, ib 96 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.6126 177 0.100071590909
 Number of poles (nbin): 1
 Total integral: 23.1153830887
 Total integral / nbin: 23.1153830887
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.770956617247 19.3301369171
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.6126
(OK)
 Check if sum of gi gives the original total integral (origint):  23.4091016575 23.1153830887
WARNING: the difference is 0.0125471952368
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.1153830887
 \sum_j^N\lambda_j = 23.4091016575
 ik, ib 97 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.7127 178 0.100071751412
 Number of poles (nbin): 1
 Total integral: 22.6773293927
 Total integral / nbin: 22.6773293927
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.7127
(OK)
 Check if sum of gi gives the original total integral (origint):  23.0370988023 22.6773293927
WARNING: the difference is 0.0156169582255
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.6773293927
 \sum_j^N\lambda_j = 23.0370988023
 ik, ib 98 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.8127 179 0.100071348315
 Number of poles (nbin): 1
 Total integral: 22.5155548071
 Total integral / nbin: 22.5155548071
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.741197141814 19.5664980741
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.8127
(OK)
 Check if sum of gi gives the original total integral (origint):  22.7806817779 22.5155548071
WARNING: the difference is 0.0116382368818
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.5155548071
 \sum_j^N\lambda_j = 22.7806817779
 ik, ib 99 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.1122 172 0.100071345029
 Number of poles (nbin): 1
 Total integral: 24.0433135857
 Total integral / nbin: 24.0433135857
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.822228967806 18.8938339332
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.1122
(OK)
 Check if sum of gi gives the original total integral (origint):  24.4024113718 24.0433135857
WARNING: the difference is 0.0147156680817
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.0433135857
 \sum_j^N\lambda_j = 24.4024113718
 ik, ib 100 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.0122 171 0.100071764706
 Number of poles (nbin): 1
 Total integral: 23.9575175498
 Total integral / nbin: 23.9575175498
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.0122
(OK)
 Check if sum of gi gives the original total integral (origint):  24.3443251757 23.9575175498
WARNING: the difference is 0.0158890264205
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.9575175498
 \sum_j^N\lambda_j = 24.3443251757
 ik, ib 101 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.3117 164 0.100071779141
 Number of poles (nbin): 1
 Total integral: 24.4243317283
 Total integral / nbin: 24.4243317283
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.3117
(OK)
 Check if sum of gi gives the original total integral (origint):  24.8076370538 24.4243317283
WARNING: the difference is 0.0154511017984
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.4243317283
 \sum_j^N\lambda_j = 24.8076370538
 ik, ib 102 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.1129 182 0.100071270718
 Number of poles (nbin): 1
 Total integral: 21.6464002413
 Total integral / nbin: 21.6464002413
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.693065940964 19.8864791639
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.1129
(OK)
 Check if sum of gi gives the original total integral (origint):  21.6497224755 21.6464002413
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.6464002413
 \sum_j^N\lambda_j = 21.6497224755
 ik, ib 103 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.3124 174 0.100071676301
 Number of poles (nbin): 1
 Total integral: 23.5052715978
 Total integral / nbin: 23.5052715978
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.3124
(OK)
 Check if sum of gi gives the original total integral (origint):  23.8757279808 23.5052715978
WARNING: the difference is 0.0155160246146
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.5052715978
 \sum_j^N\lambda_j = 23.8757279808
 ik, ib 104 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.7119 168 0.100071257485
 Number of poles (nbin): 1
 Total integral: 24.3082325364
 Total integral / nbin: 24.3082325364
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.7119
(OK)
 Check if sum of gi gives the original total integral (origint):  24.6862645014 24.3082325364
WARNING: the difference is 0.0153134535591
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.3082325364
 \sum_j^N\lambda_j = 24.6862645014
 ik, ib 105 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.18513 1192 0.10007147775
 Number of poles (nbin): 1
 Total integral: 17.5697317926
 Total integral / nbin: 17.5697317926
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.18513
(OK)
 Check if sum of gi gives the original total integral (origint):  17.7979737259 17.5697317926
WARNING: the difference is 0.0128240403551
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.5697317926
 \sum_j^N\lambda_j = 17.7979737259
 ik, ib 106 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.6119 167 0.100071686747
 Number of poles (nbin): 1
 Total integral: 24.2749414264
 Total integral / nbin: 24.2749414264
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.6119
(OK)
 Check if sum of gi gives the original total integral (origint):  24.6598213861 24.2749414264
WARNING: the difference is 0.0156075728876
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.2749414264
 \sum_j^N\lambda_j = 24.6598213861
 ik, ib 107 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.58542 1196 0.100071481172
 Number of poles (nbin): 1
 Total integral: 16.1338774274
 Total integral / nbin: 16.1338774274
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.58542
(OK)
 Check if sum of gi gives the original total integral (origint):  16.350493359 16.1338774274
WARNING: the difference is 0.0132482810653
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.1338774274
 \sum_j^N\lambda_j = 16.350493359
 ik, ib 108 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.085776 1201 0.10007148
 Number of poles (nbin): 1
 Total integral: 14.0270279178
 Total integral / nbin: 14.0270279178
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.085776
(OK)
 Check if sum of gi gives the original total integral (origint):  14.1479031745 14.0270279178
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.0270279178
 \sum_j^N\lambda_j = 14.1479031745
 ik, ib 109 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.085776 1201 0.10007148
 Number of poles (nbin): 1
 Total integral: 14.2544025243
 Total integral / nbin: 14.2544025243
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.085776
(OK)
 Check if sum of gi gives the original total integral (origint):  14.3758338737 14.2544025243
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.2544025243
 \sum_j^N\lambda_j = 14.3758338737
 ik, ib 110 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.78628 1208 0.100071483016
 Number of poles (nbin): 1
 Total integral: 10.8652684004
 Total integral / nbin: 10.8652684004
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.78628
(OK)
 Check if sum of gi gives the original total integral (origint):  10.9710731561 10.8652684004
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.8652684004
 \sum_j^N\lambda_j = 10.9710731561
 ik, ib 111 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.6862 1207 0.100071475954
 Number of poles (nbin): 1
 Total integral: 11.4086918842
 Total integral / nbin: 11.4086918842
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.6862
(OK)
 Check if sum of gi gives the original total integral (origint):  11.5182712321 11.4086918842
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.4086918842
 \sum_j^N\lambda_j = 11.5182712321
 ik, ib 112 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.9128 180 0.10007150838
 Number of poles (nbin): 1
 Total integral: 22.3944071758
 Total integral / nbin: 22.3944071758
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.730472121473 19.6142168224
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.9128
(OK)
 Check if sum of gi gives the original total integral (origint):  22.5058020425 22.3944071758
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 22.3944071758
 \sum_j^N\lambda_j = 22.5058020425
 ik, ib 113 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.0129 181 0.100071666667
 Number of poles (nbin): 1
 Total integral: 21.8757447128
 Total integral / nbin: 21.8757447128
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.71218544228 19.8045664852
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.0129
(OK)
 Check if sum of gi gives the original total integral (origint):  22.1553343984 21.8757447128
WARNING: the difference is 0.0126195200003
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.8757447128
 \sum_j^N\lambda_j = 22.1553343984
 ik, ib 114 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.1129 182 0.100071270718
 Number of poles (nbin): 1
 Total integral: 21.6993601898
 Total integral / nbin: 21.6993601898
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.699771528833 19.8644977262
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.1129
(OK)
 Check if sum of gi gives the original total integral (origint):  21.8350270393 21.6993601898
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.6993601898
 \sum_j^N\lambda_j = 21.8350270393
 ik, ib 115 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.2123 173 0.100071511628
 Number of poles (nbin): 1
 Total integral: 23.9362677702
 Total integral / nbin: 23.9362677702
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.2123
(OK)
 Check if sum of gi gives the original total integral (origint):  24.3195094526 23.9362677702
WARNING: the difference is 0.0157586107242
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.9362677702
 \sum_j^N\lambda_j = 24.3195094526
 ik, ib 116 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.2123 173 0.100071511628
 Number of poles (nbin): 1
 Total integral: 23.7066948175
 Total integral / nbin: 23.7066948175
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.2123
(OK)
 Check if sum of gi gives the original total integral (origint):  24.0838104435 23.7066948175
WARNING: the difference is 0.0156584701089
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.7066948175
 \sum_j^N\lambda_j = 24.0838104435
 ik, ib 117 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.3124 174 0.100071676301
 Number of poles (nbin): 1
 Total integral: 23.538548183
 Total integral / nbin: 23.538548183
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.3124
(OK)
 Check if sum of gi gives the original total integral (origint):  23.9101655537 23.538548183
WARNING: the difference is 0.0155422332737
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.538548183
 \sum_j^N\lambda_j = 23.9101655537
 ik, ib 118 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.7119 168 0.100071257485
 Number of poles (nbin): 1
 Total integral: 24.3291052128
 Total integral / nbin: 24.3291052128
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.842888153753 18.6466993073
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.7119
(OK)
 Check if sum of gi gives the original total integral (origint):  24.6883345992 24.3291052128
WARNING: the difference is 0.0145505718478
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.3291052128
 \sum_j^N\lambda_j = 24.6883345992
 ik, ib 119 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.5118 166 0.100071515152
 Number of poles (nbin): 1
 Total integral: 24.2853431828
 Total integral / nbin: 24.2853431828
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.5118
(OK)
 Check if sum of gi gives the original total integral (origint):  24.6762044154 24.2853431828
WARNING: the difference is 0.015839601017
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.2853431828
 \sum_j^N\lambda_j = 24.6762044154
 ik, ib 120 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 15.8113 159 0.100071518987
 Number of poles (nbin): 1
 Total integral: 24.4468750762
 Total integral / nbin: 24.4468750762
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  15.8113
(OK)
 Check if sum of gi gives the original total integral (origint):  24.8341103727 24.4468750762
WARNING: the difference is 0.0155928797399
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.4468750762
 \sum_j^N\lambda_j = 24.8341103727
 ik, ib 121 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 119.985704 1200 0.100071479566
 Number of poles (nbin): 1
 Total integral: 14.4686644068
 Total integral / nbin: 14.4686644068
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  119.985704
(OK)
 Check if sum of gi gives the original total integral (origint):  14.5912825995 14.4686644068
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.4686644068
 \sum_j^N\lambda_j = 14.5912825995
 ik, ib 122 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 120.58613 1206 0.100071477178
 Number of poles (nbin): 1
 Total integral: 11.8655375978
 Total integral / nbin: 11.8655375978
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  120.58613
(OK)
 Check if sum of gi gives the original total integral (origint):  11.9770833922 11.8655375978
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.8655375978
 \sum_j^N\lambda_j = 11.9770833922
 ik, ib 123 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.213 183 0.100071428571
 Number of poles (nbin): 1
 Total integral: 21.420749724
 Total integral / nbin: 21.420749724
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.213
(OK)
 Check if sum of gi gives the original total integral (origint):  21.7507003719 21.420749724
WARNING: the difference is 0.0151696562539
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.420749724
 \sum_j^N\lambda_j = 21.7507003719
 ik, ib 124 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.3131 184 0.100071584699
 Number of poles (nbin): 1
 Total integral: 21.283937666
 Total integral / nbin: 21.283937666
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.684017526475 20.0662260564
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.3131
(OK)
 Check if sum of gi gives the original total integral (origint):  21.5602010942 21.283937666
WARNING: the difference is 0.0128135830912
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.283937666
 \sum_j^N\lambda_j = 21.5602010942
 ik, ib 125 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.4124 175 0.100071264368
 Number of poles (nbin): 1
 Total integral: 23.3841192826
 Total integral / nbin: 23.3841192826
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.4124
(OK)
 Check if sum of gi gives the original total integral (origint):  23.7596489986 23.3841192826
WARNING: the difference is 0.0158053562169
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.3841192826
 \sum_j^N\lambda_j = 23.7596489986
 ik, ib 126 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.5125 176 0.100071428571
 Number of poles (nbin): 1
 Total integral: 23.2095847099
 Total integral / nbin: 23.2095847099
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.5125
(OK)
 Check if sum of gi gives the original total integral (origint):  23.5799628087 23.2095847099
WARNING: the difference is 0.015707323282
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.2095847099
 \sum_j^N\lambda_j = 23.5799628087
 ik, ib 127 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.812 169 0.100071428571
 Number of poles (nbin): 1
 Total integral: 24.2779425942
 Total integral / nbin: 24.2779425942
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.812
(OK)
 Check if sum of gi gives the original total integral (origint):  24.6615595047 24.2779425942
WARNING: the difference is 0.0155552575831
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.2779425942
 \sum_j^N\lambda_j = 24.6615595047
 ik, ib 128 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.812 169 0.100071428571
 Number of poles (nbin): 1
 Total integral: 24.171167957
 Total integral / nbin: 24.171167957
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.831049861267 18.7446481797
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.812
(OK)
 Check if sum of gi gives the original total integral (origint):  24.4694524823 24.171167957
WARNING: the difference is 0.012190077628
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.171167957
 \sum_j^N\lambda_j = 24.4694524823
 ik, ib 129 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.812 169 0.100071428571
 Number of poles (nbin): 1
 Total integral: 24.1214874959
 Total integral / nbin: 24.1214874959
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.812
(OK)
 Check if sum of gi gives the original total integral (origint):  24.5051348994 24.1214874959
WARNING: the difference is 0.0156557964306
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.1214874959
 \sum_j^N\lambda_j = 24.5051348994
 ik, ib 130 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.1115 162 0.100071428571
 Number of poles (nbin): 1
 Total integral: 24.4528497742
 Total integral / nbin: 24.4528497742
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.1115
(OK)
 Check if sum of gi gives the original total integral (origint):  24.8416535854 24.4528497742
WARNING: the difference is 0.0156512854467
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.4528497742
 \sum_j^N\lambda_j = 24.8416535854
 ik, ib 131 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 18.4132 185 0.10007173913
 Number of poles (nbin): 1
 Total integral: 21.1644497551
 Total integral / nbin: 21.1644497551
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.668245690585 20.1701646377
 Calculating deltai...
 Check if sum of deltai gives the original length:  18.4132
(OK)
 Check if sum of gi gives the original total integral (origint):  21.1721755789 21.1644497551
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 21.1644497551
 \sum_j^N\lambda_j = 21.1721755789
 ik, ib 132 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.7127 178 0.100071751412
 Number of poles (nbin): 1
 Total integral: 23.0310453865
 Total integral / nbin: 23.0310453865
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.7127
(OK)
 Check if sum of gi gives the original total integral (origint):  23.395739888 23.0310453865
WARNING: the difference is 0.0155880730082
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.0310453865
 \sum_j^N\lambda_j = 23.395739888
 ik, ib 133 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.9121 170 0.100071597633
 Number of poles (nbin): 1
 Total integral: 24.0430053104
 Total integral / nbin: 24.0430053104
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.821744318422 18.8462178649
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.9121
(OK)
 Check if sum of gi gives the original total integral (origint):  24.326565285 24.0430053104
WARNING: the difference is 0.0116563917398
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.0430053104
 \sum_j^N\lambda_j = 24.326565285
 ik, ib 134 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.9121 170 0.100071597633
 Number of poles (nbin): 1
 Total integral: 23.9986391567
 Total integral / nbin: 23.9986391567
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.818908394005 18.8839046668
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.9121
(OK)
 Check if sum of gi gives the original total integral (origint):  24.2910897752 23.9986391567
WARNING: the difference is 0.012039419441
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.9986391567
 \sum_j^N\lambda_j = 24.2910897752
 ik, ib 135 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.2116 163 0.100071604938
 Number of poles (nbin): 1
 Total integral: 24.4520413362
 Total integral / nbin: 24.4520413362
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.2116
(OK)
 Check if sum of gi gives the original total integral (origint):  24.8398409122 24.4520413362
WARNING: the difference is 0.0156119991823
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.4520413362
 \sum_j^N\lambda_j = 24.8398409122
 ik, ib 136 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.2116 163 0.100071604938
 Number of poles (nbin): 1
 Total integral: 24.3897666454
 Total integral / nbin: 24.3897666454
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.2116
(OK)
 Check if sum of gi gives the original total integral (origint):  24.7722810123 24.3897666454
WARNING: the difference is 0.0154412250809
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.3897666454
 \sum_j^N\lambda_j = 24.7722810123
 ik, ib 137 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 15.5111 156 0.100071612903
 Number of poles (nbin): 1
 Total integral: 24.366063292
 Total integral / nbin: 24.366063292
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  15.5111
(OK)
 Check if sum of gi gives the original total integral (origint):  24.7402831957 24.366063292
WARNING: the difference is 0.0151259345226
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.366063292
 \sum_j^N\lambda_j = 24.7402831957
 ik, ib 138 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 17.0122 171 0.100071764706
 Number of poles (nbin): 1
 Total integral: 23.9567183752
 Total integral / nbin: 23.9567183752
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  17.0122
(OK)
 Check if sum of gi gives the original total integral (origint):  24.3249672939 23.9567183752
WARNING: the difference is 0.0151387220494
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.9567183752
 \sum_j^N\lambda_j = 24.3249672939
 ik, ib 139 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 16.3117 164 0.100071779141
 Number of poles (nbin): 1
 Total integral: 24.3545750222
 Total integral / nbin: 24.3545750222
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.850798785017 18.4564460298
 Calculating deltai...
 Check if sum of deltai gives the original length:  16.3117
(OK)
 Check if sum of gi gives the original total integral (origint):  24.665777815 24.3545750222
WARNING: the difference is 0.0126167840788
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.3545750222
 \sum_j^N\lambda_j = 24.665777815
 ik, ib 140 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 15.6112 157 0.100071794872
 Number of poles (nbin): 1
 Total integral: 24.4028266457
 Total integral / nbin: 24.4028266457
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  15.6112
(OK)
 Check if sum of gi gives the original total integral (origint):  24.7886089547 24.4028266457
WARNING: the difference is 0.0155628865519
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.4028266457
 \sum_j^N\lambda_j = 24.7886089547
 ik, ib 141 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 15.5111 156 0.100071612903
 Number of poles (nbin): 1
 Total integral: 24.344815515
 Total integral / nbin: 24.344815515
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.870930638661 18.0662357143
 Calculating deltai...
 Check if sum of deltai gives the original length:  15.5111
(OK)
 Check if sum of gi gives the original total integral (origint):  24.7155977426 24.344815515
WARNING: the difference is 0.0150019526712
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.344815515
 \sum_j^N\lambda_j = 24.7155977426
 ik, ib 142 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 15.5111 156 0.100071612903
 Number of poles (nbin): 1
 Total integral: 24.337596886
 Total integral / nbin: 24.337596886
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  15.5111
(OK)
 Check if sum of gi gives the original total integral (origint):  24.718373774 24.337596886
WARNING: the difference is 0.0154046091975
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.337596886
 \sum_j^N\lambda_j = 24.718373774
 ik, ib 143 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.9107 150 0.100071812081
 Number of poles (nbin): 1
 Total integral: 24.0790005192
 Total integral / nbin: 24.0790005192
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.9107
(OK)
 Check if sum of gi gives the original total integral (origint):  24.4440791188 24.0790005192
WARNING: the difference is 0.0149352568279
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 24.0790005192
 \sum_j^N\lambda_j = 24.4440791188
 ik, ib 144 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.1101 142 0.100071631206
 Number of poles (nbin): 1
 Total integral: 23.2585976595
 Total integral / nbin: 23.2585976595
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.846973215682 17.4652091985
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.1101
(OK)
 Check if sum of gi gives the original total integral (origint):  23.2361058193 23.2585976595
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 
 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 23.2585976595
 \sum_j^N\lambda_j = 23.2361058193
 ### Writing out a_j and omega_j...
 Used time (elaps, cpu): 3.483834e+01 3.480405e+01
 Calculating multipole exponential A...
 ik, ib, ikeff, ibeff 0 0 1 5


 === Normalization test === 
 Prefactor: 0.505831218934
 Exponent: 0.681552224756
 Exponent/npoles: 0.681552224756


 ik, ib, ikeff, ibeff 1 0 2 5


 === Normalization test === 
 Prefactor: 0.527120026189
 Exponent: 0.640327002692
 Exponent/npoles: 0.640327002692


 ik, ib, ikeff, ibeff 2 0 3 5


 === Normalization test === 
 Prefactor: 0.552257197797
 Exponent: 0.593741403182
 Exponent/npoles: 0.593741403182


 ik, ib, ikeff, ibeff 3 0 4 5


 === Normalization test === 
 Prefactor: 0.594017854116
 Exponent: 0.520845902636
 Exponent/npoles: 0.520845902636


 ik, ib, ikeff, ibeff 4 0 5 5


 === Normalization test === 
 Prefactor: 0.639963660897
 Exponent: 0.446343884088
 Exponent/npoles: 0.446343884088


 ik, ib, ikeff, ibeff 5 0 6 5


 === Normalization test === 
 Prefactor: 0.702513350424
 Exponent: 0.353090873792
 Exponent/npoles: 0.353090873792


 ik, ib, ikeff, ibeff 6 0 7 5


 === Normalization test === 
 Prefactor: 0.770422654002
 Exponent: 0.260816013424
 Exponent/npoles: 0.260816013424


 ik, ib, ikeff, ibeff 7 0 8 5


 === Normalization test === 
 Prefactor: 0.86474153214
 Exponent: 0.145324623477
 Exponent/npoles: 0.145324623477


 ik, ib, ikeff, ibeff 8 0 9 5


 === Normalization test === 
 Prefactor: 0.769273149785
 Exponent: 0.262309171265
 Exponent/npoles: 0.262309171265


 This state is empty! eqpkb ik ib: 0.892090749186 9 5
 ik, ib, ikeff, ibeff 9 0 10 5


 === Normalization test === 
 Prefactor: 0.545260210853
 Exponent: 0.606492147157
 Exponent/npoles: 0.606492147157


 ik, ib, ikeff, ibeff 10 0 11 5


 === Normalization test === 
 Prefactor: 0.57727374185
 Exponent: 0.54943870236
 Exponent/npoles: 0.54943870236


 ik, ib, ikeff, ibeff 11 0 12 5


 === Normalization test === 
 Prefactor: 0.62017792607
 Exponent: 0.47774886458
 Exponent/npoles: 0.47774886458


 ik, ib, ikeff, ibeff 12 0 13 5


 === Normalization test === 
 Prefactor: 0.676142308473
 Exponent: 0.391351709601
 Exponent/npoles: 0.391351709601


 ik, ib, ikeff, ibeff 13 0 14 5


 === Normalization test === 
 Prefactor: 0.735650002535
 Exponent: 0.307000813392
 Exponent/npoles: 0.307000813392


 ik, ib, ikeff, ibeff 14 0 15 5


 === Normalization test === 
 Prefactor: 0.822313246201
 Exponent: 0.195633878414
 Exponent/npoles: 0.195633878414


 ik, ib, ikeff, ibeff 15 0 16 5


 === Normalization test === 
 Prefactor: 0.785237296232
 Exponent: 0.241769318686
 Exponent/npoles: 0.241769318686


 This state is empty! eqpkb ik ib: 0.655622735043 16 5
 ik, ib, ikeff, ibeff 16 0 17 5


 === Normalization test === 
 Prefactor: 0.614590589554
 Exponent: 0.486798940901
 Exponent/npoles: 0.486798940901


 ik, ib, ikeff, ibeff 17 0 18 5


 === Normalization test === 
 Prefactor: 0.662480145209
 Exponent: 0.411764691066
 Exponent/npoles: 0.411764691066


 ik, ib, ikeff, ibeff 18 0 19 5


 === Normalization test === 
 Prefactor: 0.715723624531
 Exponent: 0.334461185797
 Exponent/npoles: 0.334461185797


 ik, ib, ikeff, ibeff 19 0 20 5


 === Normalization test === 
 Prefactor: 0.791865862459
 Exponent: 0.233363267093
 Exponent/npoles: 0.233363267093


 ik, ib, ikeff, ibeff 20 0 21 5


 === Normalization test === 
 Prefactor: 0.807628698577
 Exponent: 0.213652857542
 Exponent/npoles: 0.213652857542


 This state is empty! eqpkb ik ib: 0.356100742213 21 5
 ik, ib, ikeff, ibeff 21 0 22 5


 === Normalization test === 
 Prefactor: 0.757834714545
 Exponent: 0.277289971807
 Exponent/npoles: 0.277289971807


 This state is empty! eqpkb ik ib: 1.06891927178 22 5
 ik, ib, ikeff, ibeff 22 0 23 5


 === Normalization test === 
 Prefactor: 0.714771563564
 Exponent: 0.335792278855
 Exponent/npoles: 0.335792278855


 ik, ib, ikeff, ibeff 23 0 24 5


 === Normalization test === 
 Prefactor: 0.775913434389
 Exponent: 0.253714318644
 Exponent/npoles: 0.253714318644


 ik, ib, ikeff, ibeff 24 0 25 5


 === Normalization test === 
 Prefactor: 0.86306278781
 Exponent: 0.147267835262
 Exponent/npoles: 0.147267835262


 ik, ib, ikeff, ibeff 25 0 26 5


 === Normalization test === 
 Prefactor: 0.765102818224
 Exponent: 0.26774505128
 Exponent/npoles: 0.26774505128


 This state is empty! eqpkb ik ib: 1.01824091803 26 5
 ik, ib, ikeff, ibeff 26 0 27 5


 === Normalization test === 
 Prefactor: 0.854336138569
 Exponent: 0.157430557754
 Exponent/npoles: 0.157430557754


 ik, ib, ikeff, ibeff 27 0 28 5


 === Normalization test === 
 Prefactor: 0.77256385203
 Exponent: 0.258040617276
 Exponent/npoles: 0.258040617276


 This state is empty! eqpkb ik ib: 0.919526772069 28 5
 ik, ib, ikeff, ibeff 28 0 29 5


 === Normalization test === 
 Prefactor: 0.730674992606
 Exponent: 0.313786524657
 Exponent/npoles: 0.313786524657


 This state is empty! eqpkb ik ib: 1.59655792208 29 5
 ik, ib, ikeff, ibeff 29 0 30 5


 === Normalization test === 
 Prefactor: 0.729406604506
 Exponent: 0.315523945937
 Exponent/npoles: 0.315523945937


 This state is empty! eqpkb ik ib: 1.70560319688 30 5
 ik, ib, ikeff, ibeff 30 0 31 5


 === Normalization test === 
 Prefactor: 0.57138498415
 Exponent: 0.559692068582
 Exponent/npoles: 0.559692068582


 ik, ib, ikeff, ibeff 31 0 32 5


 === Normalization test === 
 Prefactor: 0.607428210478
 Exponent: 0.498521282803
 Exponent/npoles: 0.498521282803


 ik, ib, ikeff, ibeff 32 0 33 5


 === Normalization test === 
 Prefactor: 0.6581801785
 Exponent: 0.418276557633
 Exponent/npoles: 0.418276557633


 ik, ib, ikeff, ibeff 33 0 34 5


 === Normalization test === 
 Prefactor: 0.710249951615
 Exponent: 0.342138326372
 Exponent/npoles: 0.342138326372


 ik, ib, ikeff, ibeff 34 0 35 5


 === Normalization test === 
 Prefactor: 0.784783989068
 Exponent: 0.242346772229
 Exponent/npoles: 0.242346772229


 ik, ib, ikeff, ibeff 35 0 36 5


 === Normalization test === 
 Prefactor: 0.810702771236
 Exponent: 0.209853788669
 Exponent/npoles: 0.209853788669


 This state is empty! eqpkb ik ib: 0.277674156707 36 5
 ik, ib, ikeff, ibeff 36 0 37 5


 === Normalization test === 
 Prefactor: 0.761330835847
 Exponent: 0.272687277291
 Exponent/npoles: 0.272687277291


 This state is empty! eqpkb ik ib: 1.00986644951 37 5
 ik, ib, ikeff, ibeff 37 0 38 5


 === Normalization test === 
 Prefactor: 0.539705393252
 Exponent: 0.616731856352
 Exponent/npoles: 0.616731856352


 ik, ib, ikeff, ibeff 38 0 39 5


 === Normalization test === 
 Prefactor: 0.650041065369
 Exponent: 0.430719740597
 Exponent/npoles: 0.430719740597


 ik, ib, ikeff, ibeff 39 0 40 5


 === Normalization test === 
 Prefactor: 0.701346406614
 Exponent: 0.354753353357
 Exponent/npoles: 0.354753353357


 ik, ib, ikeff, ibeff 40 0 41 5


 === Normalization test === 
 Prefactor: 0.761160628837
 Exponent: 0.272910867392
 Exponent/npoles: 0.272910867392


 ik, ib, ikeff, ibeff 41 0 42 5


 === Normalization test === 
 Prefactor: 0.847342799562
 Exponent: 0.165649944175
 Exponent/npoles: 0.165649944175


 ik, ib, ikeff, ibeff 42 0 43 5


 === Normalization test === 
 Prefactor: 0.772101662338
 Exponent: 0.258639050661
 Exponent/npoles: 0.258639050661


 This state is empty! eqpkb ik ib: 0.898132431012 43 5
 ik, ib, ikeff, ibeff 43 0 44 5


 === Normalization test === 
 Prefactor: 0.564911847699
 Exponent: 0.57108558178
 Exponent/npoles: 0.57108558178


 ik, ib, ikeff, ibeff 44 0 45 5


 === Normalization test === 
 Prefactor: 0.754127119073
 Exponent: 0.28219433225
 Exponent/npoles: 0.28219433225


 ik, ib, ikeff, ibeff 45 0 46 5


 === Normalization test === 
 Prefactor: 0.831402090485
 Exponent: 0.184641737751
 Exponent/npoles: 0.184641737751


 ik, ib, ikeff, ibeff 46 0 47 5


 === Normalization test === 
 Prefactor: 0.786762092901
 Exponent: 0.239829372453
 Exponent/npoles: 0.239829372453


 This state is empty! eqpkb ik ib: 0.737615402906 47 5
 ik, ib, ikeff, ibeff 47 0 48 5


 === Normalization test === 
 Prefactor: 0.739431306894
 Exponent: 0.301873892432
 Exponent/npoles: 0.301873892432


 This state is empty! eqpkb ik ib: 1.42068812216 48 5
 ik, ib, ikeff, ibeff 48 0 49 5


 === Normalization test === 
 Prefactor: 0.600625748701
 Exponent: 0.509783252721
 Exponent/npoles: 0.509783252721


 ik, ib, ikeff, ibeff 49 0 50 5


 === Normalization test === 
 Prefactor: 0.595053994795
 Exponent: 0.519103129998
 Exponent/npoles: 0.519103129998


 ik, ib, ikeff, ibeff 50 0 51 5


 === Normalization test === 
 Prefactor: 0.788130918505
 Exponent: 0.238091062689
 Exponent/npoles: 0.238091062689


 This state is empty! eqpkb ik ib: 0.680424848085 51 5
 ik, ib, ikeff, ibeff 51 0 52 5


 === Normalization test === 
 Prefactor: 0.738232693483
 Exponent: 0.303496201257
 Exponent/npoles: 0.303496201257


 This state is empty! eqpkb ik ib: 1.48776840391 52 5
 ik, ib, ikeff, ibeff 52 0 53 5


 === Normalization test === 
 Prefactor: 0.646349282355
 Exponent: 0.436415236556
 Exponent/npoles: 0.436415236556


 ik, ib, ikeff, ibeff 53 0 54 5


 === Normalization test === 
 Prefactor: 0.633868655113
 Exponent: 0.455913514599
 Exponent/npoles: 0.455913514599


 ik, ib, ikeff, ibeff 54 0 55 5


 === Normalization test === 
 Prefactor: 0.709813912214
 Exponent: 0.342752438773
 Exponent/npoles: 0.342752438773


 This state is empty! eqpkb ik ib: 2.17733957447 55 5
 ik, ib, ikeff, ibeff 55 0 56 5


 === Normalization test === 
 Prefactor: 0.703194857175
 Exponent: 0.352121246098
 Exponent/npoles: 0.352121246098


 ik, ib, ikeff, ibeff 56 0 57 5


 === Normalization test === 
 Prefactor: 0.689092988717
 Exponent: 0.372379055221
 Exponent/npoles: 0.372379055221


 ik, ib, ikeff, ibeff 57 0 58 5


 === Normalization test === 
 Prefactor: 0.682121063677
 Exponent: 0.382548124169
 Exponent/npoles: 0.382548124169


 ik, ib, ikeff, ibeff 58 0 59 5


 === Normalization test === 
 Prefactor: 0.780030886173
 Exponent: 0.248421762425
 Exponent/npoles: 0.248421762425


 ik, ib, ikeff, ibeff 59 0 60 5


 === Normalization test === 
 Prefactor: 0.74917910339
 Exponent: 0.288777200699
 Exponent/npoles: 0.288777200699


 ik, ib, ikeff, ibeff 60 0 61 5


 === Normalization test === 
 Prefactor: 0.735180616458
 Exponent: 0.30763907328
 Exponent/npoles: 0.30763907328


 ik, ib, ikeff, ibeff 61 0 62 5


 === Normalization test === 
 Prefactor: 0.818149975319
 Exponent: 0.200709615275
 Exponent/npoles: 0.200709615275


 This state is empty! eqpkb ik ib: 0.168526604527 62 5
 ik, ib, ikeff, ibeff 62 0 63 5


 === Normalization test === 
 Prefactor: 0.83621463793
 Exponent: 0.178869954916
 Exponent/npoles: 0.178869954916


 ik, ib, ikeff, ibeff 63 0 64 5


 === Normalization test === 
 Prefactor: 0.814038434185
 Exponent: 0.205747697651
 Exponent/npoles: 0.205747697651


 ik, ib, ikeff, ibeff 64 0 65 5


 === Normalization test === 
 Prefactor: 0.806510266504
 Exponent: 0.215038651797
 Exponent/npoles: 0.215038651797


 ik, ib, ikeff, ibeff 65 0 66 5


 === Normalization test === 
 Prefactor: 0.762599809433
 Exponent: 0.271021881449
 Exponent/npoles: 0.271021881449


 This state is empty! eqpkb ik ib: 0.951631663405 66 5
 ik, ib, ikeff, ibeff 66 0 67 5


 === Normalization test === 
 Prefactor: 0.778412363955
 Exponent: 0.25049886443
 Exponent/npoles: 0.25049886443


 This state is empty! eqpkb ik ib: 0.778527078135 67 5
 ik, ib, ikeff, ibeff 67 0 68 5


 === Normalization test === 
 Prefactor: 0.795362953208
 Exponent: 0.228956723597
 Exponent/npoles: 0.228956723597


 This state is empty! eqpkb ik ib: 0.555432346332 68 5
 ik, ib, ikeff, ibeff 68 0 69 5


 === Normalization test === 
 Prefactor: 0.803893799005
 Exponent: 0.218288109318
 Exponent/npoles: 0.218288109318


 This state is empty! eqpkb ik ib: 0.431465116279 69 5
 ik, ib, ikeff, ibeff 69 0 70 5


 === Normalization test === 
 Prefactor: 0.749892005125
 Exponent: 0.287826075987
 Exponent/npoles: 0.287826075987


 This state is empty! eqpkb ik ib: 1.24625895765 70 5
 ik, ib, ikeff, ibeff 70 0 71 5


 === Normalization test === 
 Prefactor: 0.750890759446
 Exponent: 0.286495097924
 Exponent/npoles: 0.286495097924


 This state is empty! eqpkb ik ib: 1.25760464146 71 5
 ik, ib, ikeff, ibeff 71 0 72 5


 === Normalization test === 
 Prefactor: 0.754696149173
 Exponent: 0.281440062165
 Exponent/npoles: 0.281440062165


 This state is empty! eqpkb ik ib: 1.21661147906 72 5
 ik, ib, ikeff, ibeff 72 0 73 5


 === Normalization test === 
 Prefactor: 0.718631107838
 Exponent: 0.330407115735
 Exponent/npoles: 0.330407115735


 This state is empty! eqpkb ik ib: 1.88880205692 73 5
 ik, ib, ikeff, ibeff 73 0 74 5


 === Normalization test === 
 Prefactor: 0.688009817211
 Exponent: 0.373952171949
 Exponent/npoles: 0.373952171949


 ik, ib, ikeff, ibeff 74 0 75 5


 === Normalization test === 
 Prefactor: 0.74938989328
 Exponent: 0.288495879129
 Exponent/npoles: 0.288495879129


 ik, ib, ikeff, ibeff 75 0 76 5


 === Normalization test === 
 Prefactor: 0.82479013245
 Exponent: 0.192626309918
 Exponent/npoles: 0.192626309918


 ik, ib, ikeff, ibeff 76 0 77 5


 === Normalization test === 
 Prefactor: 0.788421243564
 Exponent: 0.237722758907
 Exponent/npoles: 0.237722758907


 This state is empty! eqpkb ik ib: 0.676839339934 77 5
 ik, ib, ikeff, ibeff 77 0 78 5


 === Normalization test === 
 Prefactor: 0.74219185657
 Exponent: 0.298147502431
 Exponent/npoles: 0.298147502431


 This state is empty! eqpkb ik ib: 1.36247532164 78 5
 ik, ib, ikeff, ibeff 78 0 79 5


 === Normalization test === 
 Prefactor: 0.587409363379
 Exponent: 0.532033319965
 Exponent/npoles: 0.532033319965


 ik, ib, ikeff, ibeff 79 0 80 5


 === Normalization test === 
 Prefactor: 0.819647881975
 Exponent: 0.198880443174
 Exponent/npoles: 0.198880443174


 ik, ib, ikeff, ibeff 80 0 81 5


 === Normalization test === 
 Prefactor: 0.796028695856
 Exponent: 0.228120043717
 Exponent/npoles: 0.228120043717


 This state is empty! eqpkb ik ib: 0.559074506949 81 5
 ik, ib, ikeff, ibeff 81 0 82 5


 === Normalization test === 
 Prefactor: 0.744343824567
 Exponent: 0.295252221104
 Exponent/npoles: 0.295252221104


 This state is empty! eqpkb ik ib: 1.37390872964 82 5
 ik, ib, ikeff, ibeff 82 0 83 5


 === Normalization test === 
 Prefactor: 0.625875280458
 Exponent: 0.468604160226
 Exponent/npoles: 0.468604160226


 ik, ib, ikeff, ibeff 83 0 84 5


 === Normalization test === 
 Prefactor: 0.746674073433
 Exponent: 0.292126503074
 Exponent/npoles: 0.292126503074


 This state is empty! eqpkb ik ib: 1.33298249017 84 5
 ik, ib, ikeff, ibeff 84 0 85 5


 === Normalization test === 
 Prefactor: 0.71387081904
 Exponent: 0.337053258726
 Exponent/npoles: 0.337053258726


 This state is empty! eqpkb ik ib: 2.00422841012 85 5
 ik, ib, ikeff, ibeff 85 0 86 5


 === Normalization test === 
 Prefactor: 0.669700762251
 Exponent: 0.40092428987
 Exponent/npoles: 0.40092428987


 ik, ib, ikeff, ibeff 86 0 87 5


 === Normalization test === 
 Prefactor: 0.663497200379
 Exponent: 0.410230644693
 Exponent/npoles: 0.410230644693


 ik, ib, ikeff, ibeff 87 0 88 5


 === Normalization test === 
 Prefactor: 0.72296160367
 Exponent: 0.324399165191
 Exponent/npoles: 0.324399165191


 ik, ib, ikeff, ibeff 88 0 89 5


 === Normalization test === 
 Prefactor: 0.709345136079
 Exponent: 0.343413078118
 Exponent/npoles: 0.343413078118


 ik, ib, ikeff, ibeff 89 0 90 5


 === Normalization test === 
 Prefactor: 0.800142924974
 Exponent: 0.222964911053
 Exponent/npoles: 0.222964911053


 ik, ib, ikeff, ibeff 90 0 91 5


 === Normalization test === 
 Prefactor: 0.778204564953
 Exponent: 0.250765852408
 Exponent/npoles: 0.250765852408


 ik, ib, ikeff, ibeff 91 0 92 5


 === Normalization test === 
 Prefactor: 0.770000787823
 Exponent: 0.261363740988
 Exponent/npoles: 0.261363740988


 ik, ib, ikeff, ibeff 92 0 93 5


 === Normalization test === 
 Prefactor: 0.802831538858
 Exponent: 0.21961037676
 Exponent/npoles: 0.21961037676


 This state is empty! eqpkb ik ib: 0.426645693431 93 5
 ik, ib, ikeff, ibeff 93 0 94 5


 === Normalization test === 
 Prefactor: 0.865177406438
 Exponent: 0.144820698931
 Exponent/npoles: 0.144820698931


 ik, ib, ikeff, ibeff 94 0 95 5


 === Normalization test === 
 Prefactor: 0.84895355386
 Exponent: 0.163750801046
 Exponent/npoles: 0.163750801046


 ik, ib, ikeff, ibeff 95 0 96 5


 === Normalization test === 
 Prefactor: 0.753745693058
 Exponent: 0.282700244977
 Exponent/npoles: 0.282700244977


 This state is empty! eqpkb ik ib: 1.12825950553 96 5
 ik, ib, ikeff, ibeff 96 0 97 5


 === Normalization test === 
 Prefactor: 0.764211198326
 Exponent: 0.268911090418
 Exponent/npoles: 0.268911090418


 This state is empty! eqpkb ik ib: 1.02077901575 97 5
 ik, ib, ikeff, ibeff 97 0 98 5


 === Normalization test === 
 Prefactor: 0.773551941468
 Exponent: 0.256762460004
 Exponent/npoles: 0.256762460004


 This state is empty! eqpkb ik ib: 0.863901156373 98 5
 ik, ib, ikeff, ibeff 98 0 99 5


 === Normalization test === 
 Prefactor: 0.77964191851
 Exponent: 0.24892054354
 Exponent/npoles: 0.24892054354


 This state is empty! eqpkb ik ib: 0.807495567282 99 5
 ik, ib, ikeff, ibeff 99 0 100 5


 === Normalization test === 
 Prefactor: 0.73454819025
 Exponent: 0.308499675923
 Exponent/npoles: 0.308499675923


 This state is empty! eqpkb ik ib: 1.53943569291 100 5
 ik, ib, ikeff, ibeff 100 0 101 5


 === Normalization test === 
 Prefactor: 0.734512063102
 Exponent: 0.308548859947
 Exponent/npoles: 0.308548859947


 This state is empty! eqpkb ik ib: 1.6100210691 101 5
 ik, ib, ikeff, ibeff 101 0 102 5


 === Normalization test === 
 Prefactor: 0.70435127813
 Exponent: 0.350478072653
 Exponent/npoles: 0.350478072653


 This state is empty! eqpkb ik ib: 2.2962396401 102 5
 ik, ib, ikeff, ibeff 102 0 103 5


 === Normalization test === 
 Prefactor: 0.801317846167
 Exponent: 0.221497598929
 Exponent/npoles: 0.221497598929


 This state is empty! eqpkb ik ib: 0.49898702452 103 5
 ik, ib, ikeff, ibeff 103 0 104 5


 === Normalization test === 
 Prefactor: 0.748766023034
 Exponent: 0.28932873007
 Exponent/npoles: 0.28932873007


 This state is empty! eqpkb ik ib: 1.27805531025 104 5
 ik, ib, ikeff, ibeff 104 0 105 5


 === Normalization test === 
 Prefactor: 0.71594402979
 Exponent: 0.334153285761
 Exponent/npoles: 0.334153285761


 This state is empty! eqpkb ik ib: 1.94683968791 105 5
 ik, ib, ikeff, ibeff 105 0 106 5


 === Normalization test === 
 Prefactor: 0.65689494483
 Exponent: 0.420231174608
 Exponent/npoles: 0.420231174608


 ik, ib, ikeff, ibeff 106 0 107 5


 === Normalization test === 
 Prefactor: 0.715493524941
 Exponent: 0.334782729724
 Exponent/npoles: 0.334782729724


 This state is empty! eqpkb ik ib: 2.0505053886 107 5
 ik, ib, ikeff, ibeff 107 0 108 5


 === Normalization test === 
 Prefactor: 0.702648131765
 Exponent: 0.352899036281
 Exponent/npoles: 0.352899036281


 ik, ib, ikeff, ibeff 108 0 109 5


 === Normalization test === 
 Prefactor: 0.756815462834
 Exponent: 0.27863582959
 Exponent/npoles: 0.27863582959


 ik, ib, ikeff, ibeff 109 0 110 5


 === Normalization test === 
 Prefactor: 0.749890752691
 Exponent: 0.28782774614
 Exponent/npoles: 0.28782774614


 ik, ib, ikeff, ibeff 110 0 111 5


 === Normalization test === 
 Prefactor: 0.836495431618
 Exponent: 0.178534219875
 Exponent/npoles: 0.178534219875


 ik, ib, ikeff, ibeff 111 0 112 5


 === Normalization test === 
 Prefactor: 0.822975492033
 Exponent: 0.194828857566
 Exponent/npoles: 0.194828857566


 ik, ib, ikeff, ibeff 112 0 113 5


 === Normalization test === 
 Prefactor: 0.783893669644
 Exponent: 0.243481893284
 Exponent/npoles: 0.243481893284


 This state is empty! eqpkb ik ib: 0.742706354029 113 5
 ik, ib, ikeff, ibeff 113 0 114 5


 === Normalization test === 
 Prefactor: 0.794157260497
 Exponent: 0.230473776267
 Exponent/npoles: 0.230473776267


 This state is empty! eqpkb ik ib: 0.564832283256 114 5
 ik, ib, ikeff, ibeff 114 0 115 5


 === Normalization test === 
 Prefactor: 0.799003346071
 Exponent: 0.224390145401
 Exponent/npoles: 0.224390145401


 This state is empty! eqpkb ik ib: 0.504128275862 115 5
 ik, ib, ikeff, ibeff 115 0 116 5


 === Normalization test === 
 Prefactor: 0.737537954406
 Exponent: 0.304437728491
 Exponent/npoles: 0.304437728491


 This state is empty! eqpkb ik ib: 1.42296460039 116 5
 ik, ib, ikeff, ibeff 116 0 117 5


 === Normalization test === 
 Prefactor: 0.743639658132
 Exponent: 0.296198691943
 Exponent/npoles: 0.296198691943


 This state is empty! eqpkb ik ib: 1.38079050228 117 5
 ik, ib, ikeff, ibeff 117 0 118 5


 === Normalization test === 
 Prefactor: 0.749143541417
 Exponent: 0.288824669745
 Exponent/npoles: 0.288824669745


 This state is empty! eqpkb ik ib: 1.28796214519 118 5
 ik, ib, ikeff, ibeff 118 0 119 5


 === Normalization test === 
 Prefactor: 0.718772304968
 Exponent: 0.330210654353
 Exponent/npoles: 0.330210654353


 This state is empty! eqpkb ik ib: 1.949515 119 5
 ik, ib, ikeff, ibeff 119 0 120 5


 === Normalization test === 
 Prefactor: 0.71627176473
 Exponent: 0.333695624357
 Exponent/npoles: 0.333695624357


 This state is empty! eqpkb ik ib: 2.06252967742 120 5
 ik, ib, ikeff, ibeff 120 0 121 5


 === Normalization test === 
 Prefactor: 0.691588275918
 Exponent: 0.36876447743
 Exponent/npoles: 0.36876447743


 This state is empty! eqpkb ik ib: 2.75923299363 121 5
 ik, ib, ikeff, ibeff 121 0 122 5


 === Normalization test === 
 Prefactor: 0.744288482121
 Exponent: 0.295326574516
 Exponent/npoles: 0.295326574516


 ik, ib, ikeff, ibeff 122 0 123 5


 === Normalization test === 
 Prefactor: 0.810792459272
 Exponent: 0.209743164802
 Exponent/npoles: 0.209743164802


 ik, ib, ikeff, ibeff 123 0 124 5


 === Normalization test === 
 Prefactor: 0.803570597421
 Exponent: 0.218690235286
 Exponent/npoles: 0.218690235286


 This state is empty! eqpkb ik ib: 0.371701551724 124 5
 ik, ib, ikeff, ibeff 124 0 125 5


 === Normalization test === 
 Prefactor: 0.808338448287
 Exponent: 0.212774436521
 Exponent/npoles: 0.212774436521


 This state is empty! eqpkb ik ib: 0.297140638298 125 5
 ik, ib, ikeff, ibeff 125 0 126 5


 === Normalization test === 
 Prefactor: 0.754967392311
 Exponent: 0.281080719658
 Exponent/npoles: 0.281080719658


 This state is empty! eqpkb ik ib: 1.17121272251 126 5
 ik, ib, ikeff, ibeff 126 0 127 5


 === Normalization test === 
 Prefactor: 0.760920027872
 Exponent: 0.273227014853
 Exponent/npoles: 0.273227014853


 This state is empty! eqpkb ik ib: 1.0577533945 127 5
 ik, ib, ikeff, ibeff 127 0 128 5


 === Normalization test === 
 Prefactor: 0.721375459515
 Exponent: 0.326595528953
 Exponent/npoles: 0.326595528953


 This state is empty! eqpkb ik ib: 1.83354127355 128 5
 ik, ib, ikeff, ibeff 128 0 129 5


 === Normalization test === 
 Prefactor: 0.726154606404
 Exponent: 0.31999233035
 Exponent/npoles: 0.31999233035


 This state is empty! eqpkb ik ib: 1.85454983095 129 5
 ik, ib, ikeff, ibeff 129 0 130 5


 === Normalization test === 
 Prefactor: 0.725854320245
 Exponent: 0.320405945112
 Exponent/npoles: 0.320405945112


 This state is empty! eqpkb ik ib: 1.81763 130 5
 ik, ib, ikeff, ibeff 130 0 131 5


 === Normalization test === 
 Prefactor: 0.699373756883
 Exponent: 0.357569977387
 Exponent/npoles: 0.357569977387


 This state is empty! eqpkb ik ib: 2.47446873874 131 5
 ik, ib, ikeff, ibeff 131 0 132 5


 === Normalization test === 
 Prefactor: 0.814894943916
 Exponent: 0.20469607722
 Exponent/npoles: 0.20469607722


 This state is empty! eqpkb ik ib: 0.200613333333 132 5
 ik, ib, ikeff, ibeff 132 0 133 5


 === Normalization test === 
 Prefactor: 0.765085376999
 Exponent: 0.267767847462
 Exponent/npoles: 0.267767847462


 This state is empty! eqpkb ik ib: 0.940127757256 133 5
 ik, ib, ikeff, ibeff 133 0 134 5


 === Normalization test === 
 Prefactor: 0.732816101197
 Exponent: 0.310860493705
 Exponent/npoles: 0.310860493705


 This state is empty! eqpkb ik ib: 1.70928735677 134 5
 ik, ib, ikeff, ibeff 134 0 135 5


 === Normalization test === 
 Prefactor: 0.735077629385
 Exponent: 0.307779167136
 Exponent/npoles: 0.307779167136


 This state is empty! eqpkb ik ib: 1.65676389831 135 5
 ik, ib, ikeff, ibeff 135 0 136 5


 === Normalization test === 
 Prefactor: 0.704926985744
 Exponent: 0.349661047854
 Exponent/npoles: 0.349661047854


 This state is empty! eqpkb ik ib: 2.35864690231 136 5
 ik, ib, ikeff, ibeff 136 0 137 5


 === Normalization test === 
 Prefactor: 0.702408301461
 Exponent: 0.353240418022
 Exponent/npoles: 0.353240418022


 This state is empty! eqpkb ik ib: 2.43638779137 137 5
 ik, ib, ikeff, ibeff 137 0 138 5


 === Normalization test === 
 Prefactor: 0.678939733847
 Exponent: 0.387222912584
 Exponent/npoles: 0.387222912584


 This state is empty! eqpkb ik ib: 3.11352653087 138 5
 ik, ib, ikeff, ibeff 138 0 139 5


 === Normalization test === 
 Prefactor: 0.732583195878
 Exponent: 0.31117836655
 Exponent/npoles: 0.31117836655


 This state is empty! eqpkb ik ib: 1.60121629243 139 5
 ik, ib, ikeff, ibeff 139 0 140 5


 === Normalization test === 
 Prefactor: 0.708276633811
 Exponent: 0.34492053588
 Exponent/npoles: 0.34492053588


 This state is empty! eqpkb ik ib: 2.35201608247 140 5
 ik, ib, ikeff, ibeff 140 0 141 5


 === Normalization test === 
 Prefactor: 0.684070128019
 Exponent: 0.379694840272
 Exponent/npoles: 0.379694840272


 This state is empty! eqpkb ik ib: 2.99913384615 141 5
 ik, ib, ikeff, ibeff 141 0 142 5


 === Normalization test === 
 Prefactor: 0.683953724785
 Exponent: 0.379865017471
 Exponent/npoles: 0.379865017471


 This state is empty! eqpkb ik ib: 3.11061767471 142 5
 ik, ib, ikeff, ibeff 142 0 143 5


 === Normalization test === 
 Prefactor: 0.683804160545
 Exponent: 0.380083717349
 Exponent/npoles: 0.380083717349


 This state is empty! eqpkb ik ib: 3.08534548673 143 5
 ik, ib, ikeff, ibeff 143 0 144 5


 === Normalization test === 
 Prefactor: 0.662115595329
 Exponent: 0.412315122989
 Exponent/npoles: 0.412315122989


 This state is empty! eqpkb ik ib: 3.75012385742 144 5
 ik, ib, ikeff, ibeff 144 0 145 5


 === Normalization test === 
 Prefactor: 0.659056780851
 Exponent: 0.416945586051
 Exponent/npoles: 0.416945586051


 This state is empty! eqpkb ik ib: 4.46446643533 145 5

 ### Calculation of constrained retarded cumulant ### 
 ### ================== ###
 ###    Multipole fit   ###
 Number of poles: 1
 ik, ib 0 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 9.62384571197
 Total integral / nbin: 9.62384571197
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  9.70123032944 9.62384571197
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.62384571197
 \sum_j^N\lambda_j = 9.70123032944
 b_j: [ 0.05528557]
 ik, ib 1 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 9.72593441036
 Total integral / nbin: 9.72593441036
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.269220207051 23.1829650841
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  9.80384670866 9.72593441036
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.72593441036
 \sum_j^N\lambda_j = 9.80384670866
 b_j: [ 0.05641185]
 ik, ib 2 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.0393148819
 Total integral / nbin: 10.0393148819
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.1206015993 10.0393148819
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.0393148819
 \sum_j^N\lambda_j = 10.1206015993
 b_j: [ 0.06039681]
 ik, ib 3 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.5921905408
 Total integral / nbin: 10.5921905408
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.6779667092 10.5921905408
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.5921905408
 \sum_j^N\lambda_j = 10.6779667092
 b_j: [ 0.06786119]
 ik, ib 4 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.4396424882
 Total integral / nbin: 11.4396424882
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.328337335713 22.1039619762
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.4001422811 11.4396424882
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.4396424882
 \sum_j^N\lambda_j = 11.4001422811
 b_j: [ 0.07781354]
 ik, ib 5 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.6939069969
 Total integral / nbin: 12.6939069969
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.375036114852 21.4202400025
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.6187780186 12.6939069969
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.6939069969
 \sum_j^N\lambda_j = 12.6187780186
 b_j: [ 0.09675353]
 ik, ib 6 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.6285914565
 Total integral / nbin: 14.6285914565
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.7568165265 14.6285914565
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.6285914565
 \sum_j^N\lambda_j = 14.7568165265
 b_j: [ 0.13341925]
 ik, ib 7 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 17.4604552335
 Total integral / nbin: 17.4604552335
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  17.6212285711 17.4604552335
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.4604552335
 \sum_j^N\lambda_j = 17.6212285711
 b_j: [ 0.20233163]
 ik, ib 8 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.7194803699
 Total integral / nbin: 6.7194803699
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.7738565718 6.7194803699
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.7194803699
 \sum_j^N\lambda_j = 6.7738565718
 b_j: [ 0.0783525]
 ik, ib 9 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 9.93376904935
 Total integral / nbin: 9.93376904935
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.0145882698 9.93376904935
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.93376904935
 \sum_j^N\lambda_j = 10.0145882698
 b_j: [ 0.05896045]
 ik, ib 10 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.3660685358
 Total integral / nbin: 10.3660685358
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.4505573686 10.3660685358
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.3660685358
 \sum_j^N\lambda_j = 10.4505573686
 b_j: [ 0.06452587]
 ik, ib 11 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.0630663925
 Total integral / nbin: 11.0630663925
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.316745702551 22.303093981
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.0967479785 11.0630663925
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.0630663925
 \sum_j^N\lambda_j = 11.0967479785
 b_j: [ 0.07331064]
 ik, ib 12 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.1053497832
 Total integral / nbin: 12.1053497832
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.356262892968 21.7078337019
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.1480606956 12.1053497832
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.1053497832
 \sum_j^N\lambda_j = 12.1480606956
 b_j: [ 0.08862451]
 ik, ib 13 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 13.6685173119
 Total integral / nbin: 13.6685173119
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  13.7866336893 13.6685173119
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.6685173119
 \sum_j^N\lambda_j = 13.7866336893
 b_j: [ 0.1155801]
 ik, ib 14 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.2178739704
 Total integral / nbin: 16.2178739704
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.3664744792 16.2178739704
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.2178739704
 \sum_j^N\lambda_j = 16.3664744792
 b_j: [ 0.16536501]
 ik, ib 15 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 7.71177255639
 Total integral / nbin: 7.71177255639
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.78030388621 7.71177255639
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 7.71177255639
 \sum_j^N\lambda_j = 7.78030388621
 b_j: [ 0.09428321]
 ik, ib 16 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.9415822901
 Total integral / nbin: 10.9415822901
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.310888291988 22.3888892651
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.9334391504 10.9415822901
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.9415822901
 \sum_j^N\lambda_j = 10.9334391504
 b_j: [ 0.07123477]
 ik, ib 17 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.8233948042
 Total integral / nbin: 11.8233948042
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.922107434 11.8233948042
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.8233948042
 \sum_j^N\lambda_j = 11.922107434
 b_j: [ 0.08520119]
 ik, ib 18 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 13.1419159625
 Total integral / nbin: 13.1419159625
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  13.2506055405 13.1419159625
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.1419159625
 \sum_j^N\lambda_j = 13.2506055405
 b_j: [ 0.108147]
 ik, ib 19 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 15.2244284238
 Total integral / nbin: 15.2244284238
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  15.3567497934 15.2244284238
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.2244284238
 \sum_j^N\lambda_j = 15.3567497934
 b_j: [ 0.14722557]
 ik, ib 20 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.96992536924
 Total integral / nbin: 8.96992536924
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  9.04792037605 8.96992536924
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.96992536924
 \sum_j^N\lambda_j = 9.04792037605
 b_j: [ 0.11978405]
 ik, ib 21 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.20642928092
 Total integral / nbin: 6.20642928092
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.26347373861 6.20642928092
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.20642928092
 \sum_j^N\lambda_j = 6.26347373861
 b_j: [ 0.06751537]
 ik, ib 22 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.9747186383
 Total integral / nbin: 12.9747186383
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  13.0841455327 12.9747186383
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.9747186383
 \sum_j^N\lambda_j = 13.0841455327
 b_j: [ 0.10451205]
 ik, ib 23 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.7364261534
 Total integral / nbin: 14.7364261534
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.864195275 14.7364261534
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.7364261534
 \sum_j^N\lambda_j = 14.864195275
 b_j: [ 0.13758343]
 ik, ib 24 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 17.3044456245
 Total integral / nbin: 17.3044456245
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  17.4626624053 17.3044456245
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.3044456245
 \sum_j^N\lambda_j = 17.4626624053
 b_j: [ 0.20154841]
 ik, ib 25 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.58847871624
 Total integral / nbin: 6.58847871624
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.64973329586 6.58847871624
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.58847871624
 \sum_j^N\lambda_j = 6.64973329586
 b_j: [ 0.072371]
 ik, ib 26 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 17.125968693
 Total integral / nbin: 17.125968693
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.557841366281 19.5868402416
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  17.1630700078 17.125968693
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.125968693
 \sum_j^N\lambda_j = 17.1630700078
 b_j: [ 0.18674285]
 ik, ib 27 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.99486465625
 Total integral / nbin: 6.99486465625
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.05923312341 6.99486465625
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.99486465625
 \sum_j^N\lambda_j = 7.05923312341
 b_j: [ 0.07930231]
 ik, ib 28 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.08298492712
 Total integral / nbin: 5.08298492712
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.133351122 5.08298492712
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.08298492712
 \sum_j^N\lambda_j = 5.133351122
 b_j: [ 0.04749748]
 ik, ib 29 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.98315602357
 Total integral / nbin: 4.98315602357
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.03311236545 4.98315602357
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.98315602357
 \sum_j^N\lambda_j = 5.03311236545
 b_j: [ 0.04504645]
 ik, ib 30 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.2537794932
 Total integral / nbin: 10.2537794932
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.3370052804 10.2537794932
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.2537794932
 \sum_j^N\lambda_j = 10.3370052804
 b_j: [ 0.06317875]
 ik, ib 31 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.8208283228
 Total integral / nbin: 10.8208283228
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.307861328027 22.4568088455
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.8598307726 10.8208283228
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.8208283228
 \sum_j^N\lambda_j = 10.8598307726
 b_j: [ 0.06998572]
 ik, ib 32 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.687466935
 Total integral / nbin: 11.687466935
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.338771114984 21.9345380296
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.6722543463 11.687466935
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.687466935
 \sum_j^N\lambda_j = 11.6722543463
 b_j: [ 0.08194897]
 ik, ib 33 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.9825983889
 Total integral / nbin: 12.9825983889
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  13.0922483976 12.9825983889
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.9825983889
 \sum_j^N\lambda_j = 13.0922483976
 b_j: [ 0.10439474]
 ik, ib 34 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 15.0058536759
 Total integral / nbin: 15.0058536759
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  15.1355000227 15.0058536759
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.0058536759
 \sum_j^N\lambda_j = 15.1355000227
 b_j: [ 0.14223914]
 ik, ib 35 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 9.2227041108
 Total integral / nbin: 9.2227041108
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  9.30218313401 9.2227041108
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.2227041108
 \sum_j^N\lambda_j = 9.30218313401
 b_j: [ 0.12602633]
 ik, ib 36 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.36186093319
 Total integral / nbin: 6.36186093319
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.41320067793 6.36186093319
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.36186093319
 \sum_j^N\lambda_j = 6.41320067793
 b_j: [ 0.07177395]
 ik, ib 37 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 9.82921647642
 Total integral / nbin: 9.82921647642
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  9.90879082264 9.82921647642
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.82921647642
 \sum_j^N\lambda_j = 9.90879082264
 b_j: [ 0.05772086]
 ik, ib 38 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.5556181286
 Total integral / nbin: 11.5556181286
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.6514486924 11.5556181286
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.5556181286
 \sum_j^N\lambda_j = 11.6514486924
 b_j: [ 0.08124957]
 ik, ib 39 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.6589678429
 Total integral / nbin: 12.6589678429
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.7641016308 12.6589678429
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.6589678429
 \sum_j^N\lambda_j = 12.7641016308
 b_j: [ 0.09952802]
 ik, ib 40 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.318058334
 Total integral / nbin: 14.318058334
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.4421399932 14.318058334
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.318058334
 \sum_j^N\lambda_j = 14.4421399932
 b_j: [ 0.12898218]
 ik, ib 41 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.9484539804
 Total integral / nbin: 16.9484539804
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  17.1047109076 16.9484539804
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.9484539804
 \sum_j^N\lambda_j = 17.1047109076
 b_j: [ 0.18352119]
 ik, ib 42 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.96528842202
 Total integral / nbin: 6.96528842202
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.02887867759 6.96528842202
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.96528842202
 \sum_j^N\lambda_j = 7.02887867759
 b_j: [ 0.07938448]
 ik, ib 43 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.1478685305
 Total integral / nbin: 10.1478685305
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.283334139635 22.8942397961
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.1893155331 10.1478685305
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.1478685305
 \sum_j^N\lambda_j = 10.1893155331
 b_j: [ 0.06128491]
 ik, ib 44 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.1141529861
 Total integral / nbin: 14.1141529861
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.2363047574 14.1141529861
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.1141529861
 \sum_j^N\lambda_j = 14.2363047574
 b_j: [ 0.12479727]
 ik, ib 45 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.4332925904
 Total integral / nbin: 16.4332925904
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.529503510486 19.8736630128
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.5297635861 16.4332925904
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.4332925904
 \sum_j^N\lambda_j = 16.5297635861
 b_j: [ 0.16955478]
 ik, ib 46 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 7.64279965941
 Total integral / nbin: 7.64279965941
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.71154909049 7.64279965941
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 7.64279965941
 \sum_j^N\lambda_j = 7.71154909049
 b_j: [ 0.09188292]
 ik, ib 47 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.43038918423
 Total integral / nbin: 5.43038918423
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.48274233365 5.43038918423
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.43038918423
 \sum_j^N\lambda_j = 5.48274233365
 b_j: [ 0.05343143]
 ik, ib 48 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.7087378749
 Total integral / nbin: 10.7087378749
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.7964974587 10.7087378749
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.7087378749
 \sum_j^N\lambda_j = 10.7964974587
 b_j: [ 0.06903084]
 ik, ib 49 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.5955396829
 Total integral / nbin: 10.5955396829
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.300283269144 22.5907855252
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.6557088304 10.5955396829
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.5955396829
 \sum_j^N\lambda_j = 10.6557088304
 b_j: [ 0.06721662]
 ik, ib 50 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 7.87412188873
 Total integral / nbin: 7.87412188873
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.93600077319 7.87412188873
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 7.87412188873
 \sum_j^N\lambda_j = 7.93600077319
 b_j: [ 0.09819038]
 ik, ib 51 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.43194818331
 Total integral / nbin: 5.43194818331
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.48442622713 5.43194818331
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.43194818331
 \sum_j^N\lambda_j = 5.48442622713
 b_j: [ 0.05227801]
 ik, ib 52 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.5706801773
 Total integral / nbin: 11.5706801773
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.6657389092 11.5706801773
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.5706801773
 \sum_j^N\lambda_j = 11.6657389092
 b_j: [ 0.08150966]
 ik, ib 53 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.3139853402
 Total integral / nbin: 11.3139853402
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.4067334389 11.3139853402
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.3139853402
 \sum_j^N\lambda_j = 11.4067334389
 b_j: [ 0.07789856]
 ik, ib 54 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.17110810016
 Total integral / nbin: 4.17110810016
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.21484077887 4.17110810016
WARNING: the difference is 0.0103758791873
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.17110810016
 \sum_j^N\lambda_j = 4.21484077887
 b_j: [ 0.03344033]
 ik, ib 55 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.8461083369
 Total integral / nbin: 12.8461083369
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.381622379602 21.3308213712
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.7867828865 12.8461083369
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.8461083369
 \sum_j^N\lambda_j = 12.7867828865
 b_j: [ 0.09959522]
 ik, ib 56 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.3923090529
 Total integral / nbin: 12.3923090529
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.4966004996 12.3923090529
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.3923090529
 \sum_j^N\lambda_j = 12.4966004996
 b_j: [ 0.09412815]
 ik, ib 57 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.2454645069
 Total integral / nbin: 12.2454645069
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.360856196423 21.6233109453
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.2567756775 12.2454645069
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.2454645069
 \sum_j^N\lambda_j = 12.2567756775
 b_j: [ 0.09072282]
 ik, ib 58 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.8402570986
 Total integral / nbin: 14.8402570986
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.464250947543 20.461058526
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.9210976798 14.8402570986
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.8402570986
 \sum_j^N\lambda_j = 14.9210976798
 b_j: [ 0.13634823]
 ik, ib 59 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.0189199589
 Total integral / nbin: 14.0189199589
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.1414266571 14.0189199589
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.0189199589
 \sum_j^N\lambda_j = 14.1414266571
 b_j: [ 0.12216835]
 ik, ib 60 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 13.64622258
 Total integral / nbin: 13.64622258
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  13.763419413 13.64622258
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.64622258
 \sum_j^N\lambda_j = 13.763419413
 b_j: [ 0.11589746]
 ik, ib 61 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 9.44330973609
 Total integral / nbin: 9.44330973609
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  9.52519370172 9.44330973609
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.44330973609
 \sum_j^N\lambda_j = 9.52519370172
 b_j: [ 0.13271461]
 ik, ib 62 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.6519580406
 Total integral / nbin: 16.6519580406
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.8054055912 16.6519580406
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.6519580406
 \sum_j^N\lambda_j = 16.8054055912
 b_j: [ 0.17518993]
 ik, ib 63 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 15.8906619744
 Total integral / nbin: 15.8906619744
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.0294098652 15.8906619744
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.8906619744
 \sum_j^N\lambda_j = 16.0294098652
 b_j: [ 0.16103044]
 ik, ib 64 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 15.629657801
 Total integral / nbin: 15.629657801
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  15.7700238935 15.629657801
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.629657801
 \sum_j^N\lambda_j = 15.7700238935
 b_j: [ 0.15373471]
 ik, ib 65 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.52170770068
 Total integral / nbin: 6.52170770068
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.58029214603 6.52170770068
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.52170770068
 \sum_j^N\lambda_j = 6.58029214603
 b_j: [ 0.07355359]
 ik, ib 66 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 7.28625138053
 Total integral / nbin: 7.28625138053
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.35173928072 7.28625138053
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 7.28625138053
 \sum_j^N\lambda_j = 7.35173928072
 b_j: [ 0.08571592]
 ik, ib 67 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.22422715013
 Total integral / nbin: 8.22422715013
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  8.29743360624 8.22422715013
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.22422715013
 \sum_j^N\lambda_j = 8.29743360624
 b_j: [ 0.10349557]
 ik, ib 68 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.77282874345
 Total integral / nbin: 8.77282874345
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  8.84986881343 8.77282874345
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.77282874345
 \sum_j^N\lambda_j = 8.84986881343
 b_j: [ 0.11479603]
 ik, ib 69 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.78113347748
 Total integral / nbin: 5.78113347748
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.8354528273 5.78113347748
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.78113347748
 \sum_j^N\lambda_j = 5.8354528273
 b_j: [ 0.05969201]
 ik, ib 70 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.92998367019
 Total integral / nbin: 5.92998367019
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.98659068318 5.92998367019
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.92998367019
 \sum_j^N\lambda_j = 5.98659068318
 b_j: [ 0.06052598]
 ik, ib 71 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.07082591302
 Total integral / nbin: 6.07082591302
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.12873100763 6.07082591302
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.07082591302
 \sum_j^N\lambda_j = 6.12873100763
 b_j: [ 0.06270017]
 ik, ib 72 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.57826343043
 Total integral / nbin: 4.57826343043
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.62532845941 4.57826343043
WARNING: the difference is 0.0101754998358
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.57826343043
 \sum_j^N\lambda_j = 4.62532845941
 b_j: [ 0.03938126]
 ik, ib 73 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.5047104961
 Total integral / nbin: 12.5047104961
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.6073550701 12.5047104961
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.5047104961
 \sum_j^N\lambda_j = 12.6073550701
 b_j: [ 0.09790857]
 ik, ib 74 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 13.9330045945
 Total integral / nbin: 13.9330045945
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.42888178956 20.7983737282
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.0115719487 13.9330045945
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.9330045945
 \sum_j^N\lambda_j = 14.0115719487
 b_j: [ 0.12016283]
 ik, ib 75 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.2149917093
 Total integral / nbin: 16.2149917093
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.519671741309 19.9515094717
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.286386504 16.2149917093
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.2149917093
 \sum_j^N\lambda_j = 16.286386504
 b_j: [ 0.1644549]
 ik, ib 76 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 7.86657765468
 Total integral / nbin: 7.86657765468
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.92848665236 7.86657765468
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 7.86657765468
 \sum_j^N\lambda_j = 7.92848665236
 b_j: [ 0.0977385]
 ik, ib 77 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.55411949799
 Total integral / nbin: 5.55411949799
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.60670782254 5.55411949799
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.55411949799
 \sum_j^N\lambda_j = 5.60670782254
 b_j: [ 0.05570092]
 ik, ib 78 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 10.4830082399
 Total integral / nbin: 10.4830082399
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.295491059305 22.6737158237
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  10.5241473764 10.4830082399
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 10.4830082399
 \sum_j^N\lambda_j = 10.5241473764
 b_j: [ 0.06552077]
 ik, ib 79 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.0257974183
 Total integral / nbin: 16.0257974183
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.509982480921 20.0268692609
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.0430965454 16.0257974183
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.0257974183
 \sum_j^N\lambda_j = 16.0430965454
 b_j: [ 0.1595723]
 ik, ib 80 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.28831986698
 Total integral / nbin: 8.28831986698
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  8.35237564901 8.28831986698
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.28831986698
 \sum_j^N\lambda_j = 8.35237564901
 b_j: [ 0.10702416]
 ik, ib 81 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.67769703129
 Total integral / nbin: 5.67769703129
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.7321051518 5.67769703129
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.67769703129
 \sum_j^N\lambda_j = 5.7321051518
 b_j: [ 0.05653485]
 ik, ib 82 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.0705588195
 Total integral / nbin: 11.0705588195
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.1607500307 11.0705588195
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.0705588195
 \sum_j^N\lambda_j = 11.1607500307
 b_j: [ 0.07448099]
 ik, ib 83 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.79458124391
 Total integral / nbin: 5.79458124391
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.85043035035 5.79458124391
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.79458124391
 \sum_j^N\lambda_j = 5.85043035035
 b_j: [ 0.05854013]
 ik, ib 84 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.41322086891
 Total integral / nbin: 4.41322086891
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.45848378413 4.41322086891
WARNING: the difference is 0.010152086989
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.41322086891
 \sum_j^N\lambda_j = 4.45848378413
 b_j: [ 0.03708099]
 ik, ib 85 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.9772033395
 Total integral / nbin: 11.9772033395
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.0755416426 11.9772033395
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.9772033395
 \sum_j^N\lambda_j = 12.0755416426
 b_j: [ 0.08836736]
 ik, ib 86 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.8446355215
 Total integral / nbin: 11.8446355215
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.347430762063 21.8408223836
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.9194751627 11.8446355215
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.8446355215
 \sum_j^N\lambda_j = 11.9194751627
 b_j: [ 0.08501458]
 ik, ib 87 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 13.325866349
 Total integral / nbin: 13.325866349
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.400447825107 21.1155716099
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  13.2821585099 13.325866349
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.325866349
 \sum_j^N\lambda_j = 13.2821585099
 b_j: [ 0.10749916]
 ik, ib 88 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 13.0088833914
 Total integral / nbin: 13.0088833914
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.391159723009 21.2512106034
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  13.0574292757 13.0088833914
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.0088833914
 \sum_j^N\lambda_j = 13.0574292757
 b_j: [ 0.10314761]
 ik, ib 89 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 15.467306081
 Total integral / nbin: 15.467306081
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  15.6068911031 15.467306081
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.467306081
 \sum_j^N\lambda_j = 15.6068911031
 b_j: [ 0.14902455]
 ik, ib 90 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.7918555591
 Total integral / nbin: 14.7918555591
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.9229205096 14.7918555591
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.7918555591
 \sum_j^N\lambda_j = 14.9229205096
 b_j: [ 0.13609961]
 ik, ib 91 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.5772600421
 Total integral / nbin: 14.5772600421
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.7033619795 14.5772600421
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.5772600421
 \sum_j^N\lambda_j = 14.7033619795
 b_j: [ 0.13272115]
 ik, ib 92 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.70679008477
 Total integral / nbin: 8.70679008477
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  8.78285029883 8.70679008477
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.70679008477
 \sum_j^N\lambda_j = 8.78285029883
 b_j: [ 0.11393345]
 ik, ib 93 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 17.3549821562
 Total integral / nbin: 17.3549821562
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  17.5182164484 17.3549821562
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 17.3549821562
 \sum_j^N\lambda_j = 17.5182164484
 b_j: [ 0.19920746]
 ik, ib 94 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.9993791232
 Total integral / nbin: 16.9993791232
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  17.1537309483 16.9993791232
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.9993791232
 \sum_j^N\lambda_j = 17.1537309483
 b_j: [ 0.1841899]
 ik, ib 95 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.05051982811
 Total integral / nbin: 6.05051982811
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.09992109686 6.05051982811
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.05051982811
 \sum_j^N\lambda_j = 6.09992109686
 b_j: [ 0.06600988]
 ik, ib 96 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.55350838897
 Total integral / nbin: 6.55350838897
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.61451823384 6.55350838897
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.55350838897
 \sum_j^N\lambda_j = 6.61451823384
 b_j: [ 0.07172978]
 ik, ib 97 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 7.12474234525
 Total integral / nbin: 7.12474234525
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.19033019169 7.12474234525
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 7.12474234525
 \sum_j^N\lambda_j = 7.19033019169
 b_j: [ 0.08168021]
 ik, ib 98 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 7.3370892526
 Total integral / nbin: 7.3370892526
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.40392530793 7.3370892526
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 7.3370892526
 \sum_j^N\lambda_j = 7.40392530793
 b_j: [ 0.0854772]
 ik, ib 99 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.16755882679
 Total integral / nbin: 5.16755882679
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.21855747695 5.16755882679
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.16755882679
 \sum_j^N\lambda_j = 5.21855747695
 b_j: [ 0.04888281]
 ik, ib 100 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.15876268962
 Total integral / nbin: 5.15876268962
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.2103590478 5.15876268962
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.15876268962
 \sum_j^N\lambda_j = 5.2103590478
 b_j: [ 0.04757781]
 ik, ib 101 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.00549563262
 Total integral / nbin: 4.00549563262
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.04624674483 4.00549563262
WARNING: the difference is 0.0100713364208
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.00549563262
 \sum_j^N\lambda_j = 4.04624674483
 b_j: [ 0.03120264]
 ik, ib 102 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.48079010158
 Total integral / nbin: 8.48079010158
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  8.54025074494 8.48079010158
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.48079010158
 \sum_j^N\lambda_j = 8.54025074494
 b_j: [ 0.11124955]
 ik, ib 103 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.92035010306
 Total integral / nbin: 5.92035010306
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.96980898994 5.92035010306
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.92035010306
 \sum_j^N\lambda_j = 5.96980898994
 b_j: [ 0.06223428]
 ik, ib 104 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.49775971328
 Total integral / nbin: 4.49775971328
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.53622430318 4.49775971328
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.49775971328
 \sum_j^N\lambda_j = 4.53622430318
 b_j: [ 0.03985473]
 ik, ib 105 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 11.7151127175
 Total integral / nbin: 11.7151127175
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.339947054828 21.9210667012
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  11.705577469 11.7151127175
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 11.7151127175
 \sum_j^N\lambda_j = 11.705577469
 b_j: [ 0.08236878]
 ik, ib 106 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.41076943929
 Total integral / nbin: 4.41076943929
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.45266179702 4.41076943929
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.41076943929
 \sum_j^N\lambda_j = 4.45266179702
 b_j: [ 0.03659163]
 ik, ib 107 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 12.7184756098
 Total integral / nbin: 12.7184756098
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  12.8262894563 12.7184756098
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 12.7184756098
 \sum_j^N\lambda_j = 12.8262894563
 b_j: [ 0.09886953]
 ik, ib 108 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.2394269049
 Total integral / nbin: 14.2394269049
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.437965800361 20.7191552636
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.2538479194 14.2394269049
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.2394269049
 \sum_j^N\lambda_j = 14.2538479194
 b_j: [ 0.12405406]
 ik, ib 109 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 14.0791527895
 Total integral / nbin: 14.0791527895
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.2011380246 14.0791527895
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 14.0791527895
 \sum_j^N\lambda_j = 14.2011380246
 b_j: [ 0.12250156]
 ik, ib 110 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.6319388794
 Total integral / nbin: 16.6319388794
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.534082416385 19.8466141887
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.650013278 16.6319388794
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.6319388794
 \sum_j^N\lambda_j = 16.650013278
 b_j: [ 0.17172785]
 ik, ib 111 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 16.228580681
 Total integral / nbin: 16.228580681
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.518555524145 19.9831027637
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.2771386901 16.228580681
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 16.228580681
 \sum_j^N\lambda_j = 16.2771386901
 b_j: [ 0.16332286]
 ik, ib 112 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 7.51830395493
 Total integral / nbin: 7.51830395493
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  7.58642733861 7.51830395493
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 7.51830395493
 \sum_j^N\lambda_j = 7.58642733861
 b_j: [ 0.08949237]
 ik, ib 113 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.19096401558
 Total integral / nbin: 8.19096401558
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  8.26363289475 8.19096401558
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.19096401558
 \sum_j^N\lambda_j = 8.26363289475
 b_j: [ 0.10257638]
 ik, ib 114 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.4198740048
 Total integral / nbin: 8.4198740048
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  8.48581975486 8.4198740048
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.4198740048
 \sum_j^N\lambda_j = 8.48581975486
 b_j: [ 0.1090817]
 ik, ib 115 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.39079002445
 Total integral / nbin: 5.39079002445
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.4427818857 5.39079002445
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.39079002445
 \sum_j^N\lambda_j = 5.4427818857
 b_j: [ 0.05281787]
 ik, ib 116 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.62605595011
 Total integral / nbin: 5.62605595011
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.6805405536 5.62605595011
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.62605595011
 \sum_j^N\lambda_j = 5.6805405536
 b_j: [ 0.05534358]
 ik, ib 117 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.87558244273
 Total integral / nbin: 5.87558244273
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.93231606683 5.87558244273
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.87558244273
 \sum_j^N\lambda_j = 5.93231606683
 b_j: [ 0.05917794]
 ik, ib 118 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.46996834397
 Total integral / nbin: 4.46996834397
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.51619065257 4.46996834397
WARNING: the difference is 0.0102348001124
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.46996834397
 \sum_j^N\lambda_j = 4.51619065257
 b_j: [ 0.03774695]
 ik, ib 119 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.37815239781
 Total integral / nbin: 4.37815239781
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.42465985188 4.37815239781
WARNING: the difference is 0.0105109670871
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.37815239781
 \sum_j^N\lambda_j = 4.42465985188
 b_j: [ 0.03568984]
 ik, ib 120 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 3.4997266972
 Total integral / nbin: 3.4997266972
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  3.52254652962 3.4997266972
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 3.4997266972
 \sum_j^N\lambda_j = 3.52254652962
 b_j: [ 0.02690584]
 ik, ib 121 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 13.9302942814
 Total integral / nbin: 13.9302942814
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  14.0470774996 13.9302942814
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 13.9302942814
 \sum_j^N\lambda_j = 14.0470774996
 b_j: [ 0.12134673]
 ik, ib 122 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 14.99 2999 0.005
 Number of poles (nbin): 1
 Total integral: 15.9087698985
 Total integral / nbin: 15.9087698985
 Getting poles...Done.
 ibound       =    0 (should be 1) 
 Size(bounds) =    1 (should be 2) 
 Size(omegai) =    0 (should be 1) 
 ibound == nbin - 1. Calculating parameters for last bin...
 gi, omegai: 0.507880591694 20.1081083662
 Calculating deltai...
 Check if sum of deltai gives the original length:  14.99
(OK)
 Check if sum of gi gives the original total integral (origint):  16.0417857222 15.9087698985
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 15.9087698985
 \sum_j^N\lambda_j = 16.0417857222
 b_j: [ 0.1570048]
 ik, ib 123 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.80135248401
 Total integral / nbin: 8.80135248401
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  8.86909874736 8.80135248401
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.80135248401
 \sum_j^N\lambda_j = 8.86909874736
 b_j: [ 0.11820103]
 ik, ib 124 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 8.99093491939
 Total integral / nbin: 8.99093491939
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  9.05875674868 8.99093491939
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 8.99093491939
 \sum_j^N\lambda_j = 9.05875674868
 b_j: [ 0.123241]
 ik, ib 125 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.13669292168
 Total integral / nbin: 6.13669292168
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.19503750953 6.13669292168
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.13669292168
 \sum_j^N\lambda_j = 6.19503750953
 b_j: [ 0.06397916]
 ik, ib 126 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.41239509916
 Total integral / nbin: 6.41239509916
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.4652792063 6.41239509916
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.41239509916
 \sum_j^N\lambda_j = 6.4652792063
 b_j: [ 0.07026978]
 ik, ib 127 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.64090339186
 Total integral / nbin: 4.64090339186
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.68812211695 4.64090339186
WARNING: the difference is 0.0100719912818
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.64090339186
 \sum_j^N\lambda_j = 4.68812211695
 b_j: [ 0.04053287]
 ik, ib 128 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.70562199763
 Total integral / nbin: 4.70562199763
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.7538593304 4.70562199763
WARNING: the difference is 0.0101469836221
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.70562199763
 \sum_j^N\lambda_j = 4.7538593304
 b_j: [ 0.04052831]
 ik, ib 129 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.78579429227
 Total integral / nbin: 4.78579429227
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.83466229457 4.78579429227
WARNING: the difference is 0.0101078419382
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.78579429227
 \sum_j^N\lambda_j = 4.83466229457
 b_j: [ 0.0415561]
 ik, ib 130 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 3.7828386963
 Total integral / nbin: 3.7828386963
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  3.82514762784 3.7828386963
WARNING: the difference is 0.0110607316774
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 3.7828386963
 \sum_j^N\lambda_j = 3.82514762784
 b_j: [ 0.02772726]
 ik, ib 131 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 9.16191108144
 Total integral / nbin: 9.16191108144
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  9.21920640136 9.16191108144
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 9.16191108144
 \sum_j^N\lambda_j = 9.21920640136
 b_j: [ 0.13281624]
 ik, ib 132 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 6.69811363496
 Total integral / nbin: 6.69811363496
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  6.75165457809 6.69811363496
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 6.69811363496
 \sum_j^N\lambda_j = 6.75165457809
 b_j: [ 0.07612063]
 ik, ib 133 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.96683322081
 Total integral / nbin: 4.96683322081
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.01041536378 4.96683322081
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.96683322081
 \sum_j^N\lambda_j = 5.01041536378
 b_j: [ 0.04556157]
 ik, ib 134 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.06042944033
 Total integral / nbin: 5.06042944033
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.10397177747 5.06042944033
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.06042944033
 \sum_j^N\lambda_j = 5.10397177747
 b_j: [ 0.04735915]
 ik, ib 135 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 3.91142985481
 Total integral / nbin: 3.91142985481
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  3.95352396561 3.91142985481
WARNING: the difference is 0.010647238052
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 3.91142985481
 \sum_j^N\lambda_j = 3.95352396561
 b_j: [ 0.02975015]
 ik, ib 136 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 3.88745827692
 Total integral / nbin: 3.88745827692
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  3.92977196159 3.88745827692
WARNING: the difference is 0.0107674656661
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 3.88745827692
 \sum_j^N\lambda_j = 3.92977196159
 b_j: [ 0.02886741]
 ik, ib 137 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 3.15660275453
 Total integral / nbin: 3.15660275453
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  3.19416701414 3.15660275453
WARNING: the difference is 0.01176026784
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 3.15660275453
 \sum_j^N\lambda_j = 3.19416701414
 b_j: [ 0.01982699]
 ik, ib 138 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 5.15739524492
 Total integral / nbin: 5.15739524492
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  5.20174346862 5.15739524492
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 5.15739524492
 \sum_j^N\lambda_j = 5.20174346862
 b_j: [ 0.04941588]
 ik, ib 139 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 4.00628507995
 Total integral / nbin: 4.00628507995
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  4.04296043244 4.00628507995
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 4.00628507995
 \sum_j^N\lambda_j = 4.04296043244
 b_j: [ 0.03162526]
 ik, ib 140 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 3.25281312479
 Total integral / nbin: 3.25281312479
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  3.29003429636 3.25281312479
WARNING: the difference is 0.0113133080762
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 3.25281312479
 \sum_j^N\lambda_j = 3.29003429636
 b_j: [ 0.02108167]
 ik, ib 141 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 3.19173387371
 Total integral / nbin: 3.19173387371
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  3.22268630914 3.19173387371
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 3.19173387371
 \sum_j^N\lambda_j = 3.22268630914
 b_j: [ 0.0210064]
 ik, ib 142 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 3.2273457779
 Total integral / nbin: 3.2273457779
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  3.2588485435 3.2273457779
(OK)
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 3.2273457779
 \sum_j^N\lambda_j = 3.2588485435
 b_j: [ 0.02147174]
 ik, ib 143 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 2.68238308818
 Total integral / nbin: 2.68238308818
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  2.70985985656 2.68238308818
WARNING: the difference is 0.0101395532762
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 2.68238308818
 \sum_j^N\lambda_j = 2.70985985656
 b_j: [ 0.01538336]
 ik, ib 144 0
fit_multipole :: 
 Totdeltax, np.size(preen), dx: 30.0 6001 0.005
 Number of poles (nbin): 1
 Total integral: 2.24834908987
 Total integral / nbin: 2.24834908987
 Getting poles...Done.
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 ibound == nbin, Fixing last value
 Calculating deltai...
 Check if sum of deltai gives the original length:  30.0
(OK)
 Check if sum of gi gives the original total integral (origint):  2.27354601812 2.24834908987
WARNING: the difference is 0.0110826559243
 ibound       =    1 (should be 1) 
 Size(bounds) =    2 (should be 2) 
 Size(omegai) =    1 (should be 1) 
 Size(deltai) =    1 (should be 1) 

 Integral test. Compare \int\Sigma and \sum_j^N\lambda_j.
 1/pi*\int\Sigma   = 2.24834908987
 \sum_j^N\lambda_j = 2.27354601812
 b_j: [ 0.01106235]

 ### Writing out a_j and omega_j...
 ik, ib, ikeff, ibeff 0 0 0 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000948016790708
 Prefactor: 0.946214896342
 Exponent: 0.0552855725753
 Exponent/npoles: 0.0552855725753


 ik, ib, ikeff, ibeff 1 0 1 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.011494832766
 Prefactor: 0.945149799953
 Exponent: 0.0564118455819
 Exponent/npoles: 0.0564118455819


 ik, ib, ikeff, ibeff 2 0 2 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0103846086012
 Prefactor: 0.941390908069
 Exponent: 0.0603968079442
 Exponent/npoles: 0.0603968079442


 ik, ib, ikeff, ibeff 3 0 3 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00855479013475
 Prefactor: 0.934390165214
 Exponent: 0.0678611922058
 Exponent/npoles: 0.0678611922058


 ik, ib, ikeff, ibeff 4 0 4 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00612584910113
 Prefactor: 0.925136911998
 Exponent: 0.0778135394518
 Exponent/npoles: 0.0778135394518


 ik, ib, ikeff, ibeff 5 0 5 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00350375812513
 Prefactor: 0.907779715039
 Exponent: 0.0967535343968
 Exponent/npoles: 0.0967535343968


 ik, ib, ikeff, ibeff 6 0 6 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00118468988297
 Prefactor: 0.87509813105
 Exponent: 0.133419249142
 Exponent/npoles: 0.133419249142


 ik, ib, ikeff, ibeff 7 0 7 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 9.81754840497e-06
 Prefactor: 0.8168240008
 Exponent: 0.202331628626
 Exponent/npoles: 0.202331628626


 ik, ib, ikeff, ibeff 8 0 8 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000426669601228
 Prefactor: 0.92463843764
 Exponent: 0.0783524961097
 Exponent/npoles: 0.0783524961097


 This state is empty! eqpkb ik ib: 0.892090749186 9 5
 ik, ib, ikeff, ibeff 9 0 9 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0215200236258
 Prefactor: 0.942744052013
 Exponent: 0.0589604520514
 Exponent/npoles: 0.0589604520514


 ik, ib, ikeff, ibeff 10 0 10 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0371511729376
 Prefactor: 0.937511863963
 Exponent: 0.0645258663235
 Exponent/npoles: 0.0645258663235


 ik, ib, ikeff, ibeff 11 0 11 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0285782378131
 Prefactor: 0.929312099149
 Exponent: 0.0733106448663
 Exponent/npoles: 0.0733106448663


 ik, ib, ikeff, ibeff 12 0 12 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0185747521679
 Prefactor: 0.915189150462
 Exponent: 0.0886245132542
 Exponent/npoles: 0.0886245132542


 ik, ib, ikeff, ibeff 13 0 13 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00851320588164
 Prefactor: 0.890849212038
 Exponent: 0.115580100358
 Exponent/npoles: 0.115580100358


 ik, ib, ikeff, ibeff 14 0 14 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0013373532
 Prefactor: 0.847584271715
 Exponent: 0.165365009018
 Exponent/npoles: 0.165365009018


 ik, ib, ikeff, ibeff 15 0 15 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00165490937919
 Prefactor: 0.910025002072
 Exponent: 0.0942832050439
 Exponent/npoles: 0.0942832050439


 This state is empty! eqpkb ik ib: 0.655622735043 16 5
 ik, ib, ikeff, ibeff 16 0 16 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0150099017796
 Prefactor: 0.931243234886
 Exponent: 0.0712347738664
 Exponent/npoles: 0.0712347738664


 ik, ib, ikeff, ibeff 17 0 17 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0208695093137
 Prefactor: 0.918327508102
 Exponent: 0.0852011893475
 Exponent/npoles: 0.0852011893475


 ik, ib, ikeff, ibeff 18 0 18 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0110951508667
 Prefactor: 0.897495657513
 Exponent: 0.108146997057
 Exponent/npoles: 0.108146997057


 ik, ib, ikeff, ibeff 19 0 19 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00320249047255
 Prefactor: 0.863099269625
 Exponent: 0.14722556598
 Exponent/npoles: 0.14722556598


 ik, ib, ikeff, ibeff 20 0 20 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000454005042859
 Prefactor: 0.887111987276
 Exponent: 0.119784050667
 Exponent/npoles: 0.119784050667


 This state is empty! eqpkb ik ib: 0.356100742213 21 5
 ik, ib, ikeff, ibeff 21 0 21 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00248410971219
 Prefactor: 0.934713350798
 Exponent: 0.0675153733843
 Exponent/npoles: 0.0675153733843


 This state is empty! eqpkb ik ib: 1.06891927178 22 5
 ik, ib, ikeff, ibeff 22 0 22 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00605019626929
 Prefactor: 0.900763945678
 Exponent: 0.104512047178
 Exponent/npoles: 0.104512047178


 ik, ib, ikeff, ibeff 23 0 23 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00424302018373
 Prefactor: 0.871461640317
 Exponent: 0.137583430691
 Exponent/npoles: 0.137583430691


 ik, ib, ikeff, ibeff 24 0 24 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 7.99113818808e-06
 Prefactor: 0.817464001696
 Exponent: 0.201548411804
 Exponent/npoles: 0.201548411804


 ik, ib, ikeff, ibeff 25 0 25 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00424125300085
 Prefactor: 0.93018572955
 Exponent: 0.0723710035805
 Exponent/npoles: 0.0723710035805


 This state is empty! eqpkb ik ib: 1.01824091803 26 5
 ik, ib, ikeff, ibeff 26 0 26 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000122686459457
 Prefactor: 0.829657051342
 Exponent: 0.186742854733
 Exponent/npoles: 0.186742854733


 ik, ib, ikeff, ibeff 27 0 27 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00335960956144
 Prefactor: 0.92376062429
 Exponent: 0.0793023055242
 Exponent/npoles: 0.0793023055242


 This state is empty! eqpkb ik ib: 0.919526772069 28 5
 ik, ib, ikeff, ibeff 28 0 28 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00531169359127
 Prefactor: 0.953612878332
 Exponent: 0.0474974777999
 Exponent/npoles: 0.0474974777999


 This state is empty! eqpkb ik ib: 1.59655792208 29 5
 ik, ib, ikeff, ibeff 29 0 29 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00583104575175
 Prefactor: 0.955953072068
 Exponent: 0.0450464549301
 Exponent/npoles: 0.0450464549301


 This state is empty! eqpkb ik ib: 1.70560319688 30 5
 ik, ib, ikeff, ibeff 30 0 30 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00644551783333
 Prefactor: 0.938775653383
 Exponent: 0.063178749105
 Exponent/npoles: 0.063178749105


 ik, ib, ikeff, ibeff 31 0 31 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0156740569539
 Prefactor: 0.932407131177
 Exponent: 0.0699857236547
 Exponent/npoles: 0.0699857236547


 ik, ib, ikeff, ibeff 32 0 32 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0110621785833
 Prefactor: 0.921318969312
 Exponent: 0.0819489733562
 Exponent/npoles: 0.0819489733562


 ik, ib, ikeff, ibeff 33 0 33 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00599230098333
 Prefactor: 0.900869621316
 Exponent: 0.104394736266
 Exponent/npoles: 0.104394736266


 ik, ib, ikeff, ibeff 34 0 34 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00184698026333
 Prefactor: 0.86741379801
 Exponent: 0.142239140387
 Exponent/npoles: 0.142239140387


 ik, ib, ikeff, ibeff 35 0 35 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000169485427554
 Prefactor: 0.881591634377
 Exponent: 0.126026329765
 Exponent/npoles: 0.126026329765


 This state is empty! eqpkb ik ib: 0.277674156707 36 5
 ik, ib, ikeff, ibeff 36 0 36 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00110663587426
 Prefactor: 0.930741262307
 Exponent: 0.0717739540714
 Exponent/npoles: 0.0717739540714


 This state is empty! eqpkb ik ib: 1.00986644951 37 5
 ik, ib, ikeff, ibeff 37 0 37 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00558090029205
 Prefactor: 0.943913394264
 Exponent: 0.0577208604092
 Exponent/npoles: 0.0577208604092


 ik, ib, ikeff, ibeff 38 0 38 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0116993083316
 Prefactor: 0.92196356817
 Exponent: 0.0812495701215
 Exponent/npoles: 0.0812495701215


 ik, ib, ikeff, ibeff 39 0 39 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0140419000354
 Prefactor: 0.905264584363
 Exponent: 0.099528019599
 Exponent/npoles: 0.099528019599


 ik, ib, ikeff, ibeff 40 0 40 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00545842007158
 Prefactor: 0.878989625446
 Exponent: 0.128982184044
 Exponent/npoles: 0.128982184044


 ik, ib, ikeff, ibeff 41 0 41 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000388871055066
 Prefactor: 0.832334241927
 Exponent: 0.183521185748
 Exponent/npoles: 0.183521185748


 ik, ib, ikeff, ibeff 42 0 42 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00325774985063
 Prefactor: 0.923684713302
 Exponent: 0.0793844849395
 Exponent/npoles: 0.0793844849395


 This state is empty! eqpkb ik ib: 0.898132431012 43 5
 ik, ib, ikeff, ibeff 43 0 43 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0201381293273
 Prefactor: 0.940555231534
 Exponent: 0.0612849062517
 Exponent/npoles: 0.0612849062517


 ik, ib, ikeff, ibeff 44 0 44 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00306850562818
 Prefactor: 0.88267582813
 Exponent: 0.124797271346
 Exponent/npoles: 0.124797271346


 ik, ib, ikeff, ibeff 45 0 45 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000783994058537
 Prefactor: 0.844040515654
 Exponent: 0.169554781209
 Exponent/npoles: 0.169554781209


 ik, ib, ikeff, ibeff 46 0 46 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00202083733954
 Prefactor: 0.912211947394
 Exponent: 0.0918829174495
 Exponent/npoles: 0.0918829174495


 This state is empty! eqpkb ik ib: 0.737615402906 47 5
 ik, ib, ikeff, ibeff 47 0 47 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00424676132807
 Prefactor: 0.947970941224
 Exponent: 0.0534314299138
 Exponent/npoles: 0.0534314299138


 This state is empty! eqpkb ik ib: 1.42068812216 48 5
 ik, ib, ikeff, ibeff 48 0 48 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0164150795441
 Prefactor: 0.933297896433
 Exponent: 0.0690308403152
 Exponent/npoles: 0.0690308403152


 ik, ib, ikeff, ibeff 49 0 49 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0171717431252
 Prefactor: 0.934992638039
 Exponent: 0.0672166234795
 Exponent/npoles: 0.0672166234795


 ik, ib, ikeff, ibeff 50 0 50 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000828379050515
 Prefactor: 0.906476310874
 Exponent: 0.0981903816446
 Exponent/npoles: 0.0981903816446


 This state is empty! eqpkb ik ib: 0.680424848085 51 5
 ik, ib, ikeff, ibeff 51 0 51 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00888015079698
 Prefactor: 0.949064979877
 Exponent: 0.0522780107696
 Exponent/npoles: 0.0522780107696


 This state is empty! eqpkb ik ib: 1.48776840391 52 5
 ik, ib, ikeff, ibeff 52 0 52 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0116014604618
 Prefactor: 0.921723806653
 Exponent: 0.0815096592468
 Exponent/npoles: 0.0815096592468


 ik, ib, ikeff, ibeff 53 0 53 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0259122351683
 Prefactor: 0.925058263203
 Exponent: 0.0778985562066
 Exponent/npoles: 0.0778985562066


 ik, ib, ikeff, ibeff 54 0 54 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00299616510473
 Prefactor: 0.967112613577
 Exponent: 0.0334403336629
 Exponent/npoles: 0.0334403336629


 This state is empty! eqpkb ik ib: 2.17733957447 55 5
 ik, ib, ikeff, ibeff 55 0 55 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00649013014638
 Prefactor: 0.905203750222
 Exponent: 0.0995952222547
 Exponent/npoles: 0.0995952222547


 ik, ib, ikeff, ibeff 56 0 56 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0162516749472
 Prefactor: 0.910166117792
 Exponent: 0.0941281491062
 Exponent/npoles: 0.0941281491062


 ik, ib, ikeff, ibeff 57 0 57 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00870471410931
 Prefactor: 0.913270819235
 Exponent: 0.0907228167035
 Exponent/npoles: 0.0907228167035


 ik, ib, ikeff, ibeff 58 0 58 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00212655701385
 Prefactor: 0.872538733973
 Exponent: 0.136348231652
 Exponent/npoles: 0.136348231652


 ik, ib, ikeff, ibeff 59 0 59 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00684242026125
 Prefactor: 0.884999366985
 Exponent: 0.122168349246
 Exponent/npoles: 0.122168349246


 ik, ib, ikeff, ibeff 60 0 60 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00848715510918
 Prefactor: 0.890566537357
 Exponent: 0.115897459945
 Exponent/npoles: 0.115897459945


 ik, ib, ikeff, ibeff 61 0 61 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000104877131479
 Prefactor: 0.8757149725
 Exponent: 0.13271461485
 Exponent/npoles: 0.13271461485


 This state is empty! eqpkb ik ib: 0.168526604527 62 5
 ik, ib, ikeff, ibeff 62 0 62 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000783550288342
 Prefactor: 0.839297597896
 Exponent: 0.17518992993
 Exponent/npoles: 0.17518992993


 ik, ib, ikeff, ibeff 63 0 63 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00172286664968
 Prefactor: 0.851266156409
 Exponent: 0.161030442069
 Exponent/npoles: 0.161030442069


 ik, ib, ikeff, ibeff 64 0 64 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00109739706282
 Prefactor: 0.857499472712
 Exponent: 0.153734714855
 Exponent/npoles: 0.153734714855


 ik, ib, ikeff, ibeff 65 0 65 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000975574615361
 Prefactor: 0.929086356802
 Exponent: 0.0735535877587
 Exponent/npoles: 0.0735535877587


 This state is empty! eqpkb ik ib: 0.951631663405 66 5
 ik, ib, ikeff, ibeff 66 0 66 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0024293220297
 Prefactor: 0.917854935181
 Exponent: 0.0857159235272
 Exponent/npoles: 0.0857159235272


 This state is empty! eqpkb ik ib: 0.778527078135 67 5
 ik, ib, ikeff, ibeff 67 0 67 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00109026245768
 Prefactor: 0.901680016147
 Exponent: 0.103495571141
 Exponent/npoles: 0.103495571141


 This state is empty! eqpkb ik ib: 0.555432346332 68 5
 ik, ib, ikeff, ibeff 68 0 68 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000622735653758
 Prefactor: 0.891547977031
 Exponent: 0.114796027051
 Exponent/npoles: 0.114796027051


 This state is empty! eqpkb ik ib: 0.431465116279 69 5
 ik, ib, ikeff, ibeff 69 0 69 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00339861545345
 Prefactor: 0.942054635149
 Exponent: 0.0596920069908
 Exponent/npoles: 0.0596920069908


 This state is empty! eqpkb ik ib: 1.24625895765 70 5
 ik, ib, ikeff, ibeff 70 0 70 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00654520768837
 Prefactor: 0.941269313383
 Exponent: 0.0605259812125
 Exponent/npoles: 0.0605259812125


 This state is empty! eqpkb ik ib: 1.25760464146 71 5
 ik, ib, ikeff, ibeff 71 0 71 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00302474153745
 Prefactor: 0.9392250406
 Exponent: 0.0627001686366
 Exponent/npoles: 0.0627001686366


 This state is empty! eqpkb ik ib: 1.21661147906 72 5
 ik, ib, ikeff, ibeff 72 0 72 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00710600385084
 Prefactor: 0.961384104838
 Exponent: 0.0393812570087
 Exponent/npoles: 0.0393812570087


 This state is empty! eqpkb ik ib: 1.88880205692 73 5
 ik, ib, ikeff, ibeff 73 0 73 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00248669507473
 Prefactor: 0.906731806646
 Exponent: 0.0979085653757
 Exponent/npoles: 0.0979085653757


 ik, ib, ikeff, ibeff 74 0 74 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00347011462589
 Prefactor: 0.886776030032
 Exponent: 0.120162831339
 Exponent/npoles: 0.120162831339


 ik, ib, ikeff, ibeff 75 0 75 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000508706980693
 Prefactor: 0.848356017659
 Exponent: 0.16445489915
 Exponent/npoles: 0.16445489915


 ik, ib, ikeff, ibeff 76 0 76 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000826915591352
 Prefactor: 0.906886019444
 Exponent: 0.0977385044112
 Exponent/npoles: 0.0977385044112


 This state is empty! eqpkb ik ib: 0.676839339934 77 5
 ik, ib, ikeff, ibeff 77 0 77 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00196495537588
 Prefactor: 0.945821971338
 Exponent: 0.0557009186148
 Exponent/npoles: 0.0557009186148


 This state is empty! eqpkb ik ib: 1.36247532164 78 5
 ik, ib, ikeff, ibeff 78 0 78 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00445060462594
 Prefactor: 0.936579593985
 Exponent: 0.0655207698015
 Exponent/npoles: 0.0655207698015


 ik, ib, ikeff, ibeff 79 0 79 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000666402856481
 Prefactor: 0.852508332669
 Exponent: 0.159572295481
 Exponent/npoles: 0.159572295481


 ik, ib, ikeff, ibeff 80 0 80 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00101152582035
 Prefactor: 0.898503967923
 Exponent: 0.107024156605
 Exponent/npoles: 0.107024156605


 This state is empty! eqpkb ik ib: 0.559074506949 81 5
 ik, ib, ikeff, ibeff 81 0 81 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00761495023764
 Prefactor: 0.94503354499
 Exponent: 0.0565348547747
 Exponent/npoles: 0.0565348547747


 This state is empty! eqpkb ik ib: 1.37390872964 82 5
 ik, ib, ikeff, ibeff 82 0 82 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0143898730101
 Prefactor: 0.928225122347
 Exponent: 0.0744809868798
 Exponent/npoles: 0.0744809868798


 ik, ib, ikeff, ibeff 83 0 83 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00356967675676
 Prefactor: 0.943140387224
 Exponent: 0.0585401344446
 Exponent/npoles: 0.0585401344446


 This state is empty! eqpkb ik ib: 1.33298249017 84 5
 ik, ib, ikeff, ibeff 84 0 84 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00781667337296
 Prefactor: 0.963598091482
 Exponent: 0.0370809888557
 Exponent/npoles: 0.0370809888557


 This state is empty! eqpkb ik ib: 2.00422841012 85 5
 ik, ib, ikeff, ibeff 85 0 85 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00983489095962
 Prefactor: 0.915424523429
 Exponent: 0.0883673612715
 Exponent/npoles: 0.0883673612715


 ik, ib, ikeff, ibeff 86 0 86 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0104446021429
 Prefactor: 0.918498895069
 Exponent: 0.085014577301
 Exponent/npoles: 0.085014577301


 ik, ib, ikeff, ibeff 87 0 87 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00514878623048
 Prefactor: 0.898077279862
 Exponent: 0.10749915663
 Exponent/npoles: 0.10749915663


 ik, ib, ikeff, ibeff 88 0 88 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0120243771694
 Prefactor: 0.90199381935
 Exponent: 0.103147611105
 Exponent/npoles: 0.103147611105


 ik, ib, ikeff, ibeff 89 0 89 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00135370549369
 Prefactor: 0.861547966078
 Exponent: 0.149024547166
 Exponent/npoles: 0.149024547166


 ik, ib, ikeff, ibeff 90 0 90 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00423317645426
 Prefactor: 0.872755691407
 Exponent: 0.136099611784
 Exponent/npoles: 0.136099611784


 ik, ib, ikeff, ibeff 91 0 91 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00238046054689
 Prefactor: 0.875709252075
 Exponent: 0.132721147162
 Exponent/npoles: 0.132721147162


 ik, ib, ikeff, ibeff 92 0 92 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000319707167677
 Prefactor: 0.892317335047
 Exponent: 0.113933452889
 Exponent/npoles: 0.113933452889


 This state is empty! eqpkb ik ib: 0.426645693431 93 5
 ik, ib, ikeff, ibeff 93 0 93 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 5.93098416496e-06
 Prefactor: 0.81937988795
 Exponent: 0.19920745902
 Exponent/npoles: 0.19920745902


 ik, ib, ikeff, ibeff 94 0 94 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000386589831985
 Prefactor: 0.831777832162
 Exponent: 0.184189902471
 Exponent/npoles: 0.184189902471


 ik, ib, ikeff, ibeff 95 0 95 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00139011798072
 Prefactor: 0.936121612145
 Exponent: 0.0660098834396
 Exponent/npoles: 0.0660098834396


 This state is empty! eqpkb ik ib: 1.12825950553 96 5
 ik, ib, ikeff, ibeff 96 0 96 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0042988694136
 Prefactor: 0.930782376897
 Exponent: 0.0717297810198
 Exponent/npoles: 0.0717297810198


 This state is empty! eqpkb ik ib: 1.02077901575 97 5
 ik, ib, ikeff, ibeff 97 0 97 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00297820220465
 Prefactor: 0.92156662383
 Exponent: 0.0816802051586
 Exponent/npoles: 0.0816802051586


 This state is empty! eqpkb ik ib: 0.863901156373 98 5
 ik, ib, ikeff, ibeff 98 0 98 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00129746088287
 Prefactor: 0.918074071472
 Exponent: 0.0854772037384
 Exponent/npoles: 0.0854772037384


 This state is empty! eqpkb ik ib: 0.807495567282 99 5
 ik, ib, ikeff, ibeff 99 0 99 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00501319427295
 Prefactor: 0.952292721285
 Exponent: 0.0488828111116
 Exponent/npoles: 0.0488828111116


 This state is empty! eqpkb ik ib: 1.53943569291 100 5
 ik, ib, ikeff, ibeff 100 0 100 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0104106783569
 Prefactor: 0.953536276614
 Exponent: 0.0475778089248
 Exponent/npoles: 0.0475778089248


 This state is empty! eqpkb ik ib: 1.6100210691 101 5
 ik, ib, ikeff, ibeff 101 0 101 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00327028789874
 Prefactor: 0.969279134135
 Exponent: 0.0312026444507
 Exponent/npoles: 0.0312026444507


 This state is empty! eqpkb ik ib: 2.2962396401 102 5
 ik, ib, ikeff, ibeff 102 0 102 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000131030494783
 Prefactor: 0.894715447661
 Exponent: 0.111249546834
 Exponent/npoles: 0.111249546834


 This state is empty! eqpkb ik ib: 0.49898702452 103 5
 ik, ib, ikeff, ibeff 103 0 103 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00329108660185
 Prefactor: 0.939662716326
 Exponent: 0.0622342805254
 Exponent/npoles: 0.0622342805254


 This state is empty! eqpkb ik ib: 1.27805531025 104 5
 ik, ib, ikeff, ibeff 104 0 104 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00369740758925
 Prefactor: 0.96092902415
 Exponent: 0.0398547289825
 Exponent/npoles: 0.0398547289825


 This state is empty! eqpkb ik ib: 1.94683968791 105 5
 ik, ib, ikeff, ibeff 105 0 105 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00274549198461
 Prefactor: 0.920932279187
 Exponent: 0.0823687750863
 Exponent/npoles: 0.0823687750863


 ik, ib, ikeff, ibeff 106 0 106 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00795018065186
 Prefactor: 0.964069755516
 Exponent: 0.0365916264961
 Exponent/npoles: 0.0365916264961


 This state is empty! eqpkb ik ib: 2.0505053886 107 5
 ik, ib, ikeff, ibeff 107 0 107 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00701944623609
 Prefactor: 0.905860887207
 Exponent: 0.0988695308576
 Exponent/npoles: 0.0988695308576


 ik, ib, ikeff, ibeff 108 0 108 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00303952016303
 Prefactor: 0.883332082787
 Exponent: 0.124054064383
 Exponent/npoles: 0.124054064383


 ik, ib, ikeff, ibeff 109 0 109 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00340406548056
 Prefactor: 0.884704528898
 Exponent: 0.122501555371
 Exponent/npoles: 0.122501555371


 ik, ib, ikeff, ibeff 110 0 110 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000380036260179
 Prefactor: 0.842208346264
 Exponent: 0.17172785323
 Exponent/npoles: 0.17172785323


 ik, ib, ikeff, ibeff 111 0 111 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00129987789229
 Prefactor: 0.849316932332
 Exponent: 0.163322861585
 Exponent/npoles: 0.163322861585


 ik, ib, ikeff, ibeff 112 0 112 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00106706993891
 Prefactor: 0.914395245898
 Exponent: 0.089492365664
 Exponent/npoles: 0.089492365664


 This state is empty! eqpkb ik ib: 0.742706354029 113 5
 ik, ib, ikeff, ibeff 113 0 113 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00113957731739
 Prefactor: 0.902509210536
 Exponent: 0.102576383247
 Exponent/npoles: 0.102576383247


 This state is empty! eqpkb ik ib: 0.564832283256 114 5
 ik, ib, ikeff, ibeff 114 0 114 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000434727483245
 Prefactor: 0.896657158738
 Exponent: 0.109081698748
 Exponent/npoles: 0.109081698748


 This state is empty! eqpkb ik ib: 0.504128275862 115 5
 ik, ib, ikeff, ibeff 115 0 115 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00213854992228
 Prefactor: 0.94855275367
 Exponent: 0.0528178731573
 Exponent/npoles: 0.0528178731573


 This state is empty! eqpkb ik ib: 1.42296460039 116 5
 ik, ib, ikeff, ibeff 116 0 116 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00776284066983
 Prefactor: 0.946160009845
 Exponent: 0.0553435806341
 Exponent/npoles: 0.0553435806341


 This state is empty! eqpkb ik ib: 1.38079050228 117 5
 ik, ib, ikeff, ibeff 117 0 117 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00673351807601
 Prefactor: 0.942539040091
 Exponent: 0.0591779386704
 Exponent/npoles: 0.0591779386704


 This state is empty! eqpkb ik ib: 1.28796214519 118 5
 ik, ib, ikeff, ibeff 118 0 118 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00752030149346
 Prefactor: 0.962956588195
 Exponent: 0.0377469479558
 Exponent/npoles: 0.0377469479558


 This state is empty! eqpkb ik ib: 1.949515 119 5
 ik, ib, ikeff, ibeff 119 0 119 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00807432208197
 Prefactor: 0.964939528088
 Exponent: 0.0356898448001
 Exponent/npoles: 0.0356898448001


 This state is empty! eqpkb ik ib: 2.06252967742 120 5
 ik, ib, ikeff, ibeff 120 0 120 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00109246936736
 Prefactor: 0.973452892834
 Exponent: 0.026905844828
 Exponent/npoles: 0.026905844828


 This state is empty! eqpkb ik ib: 2.75923299363 121 5
 ik, ib, ikeff, ibeff 121 0 121 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000947794736175
 Prefactor: 0.885726794442
 Exponent: 0.121346734346
 Exponent/npoles: 0.121346734346


 ik, ib, ikeff, ibeff 122 0 122 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00102098650286
 Prefactor: 0.854699955468
 Exponent: 0.157004800912
 Exponent/npoles: 0.157004800912


 ik, ib, ikeff, ibeff 123 0 123 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00023140759234
 Prefactor: 0.888517418225
 Exponent: 0.1182010275
 Exponent/npoles: 0.1182010275


 This state is empty! eqpkb ik ib: 0.371701551724 124 5
 ik, ib, ikeff, ibeff 124 0 124 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.000173187019009
 Prefactor: 0.884050580602
 Exponent: 0.123241000106
 Exponent/npoles: 0.123241000106


 This state is empty! eqpkb ik ib: 0.297140638298 125 5
 ik, ib, ikeff, ibeff 125 0 125 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00280603116887
 Prefactor: 0.938024548706
 Exponent: 0.0639791589898
 Exponent/npoles: 0.0639791589898


 This state is empty! eqpkb ik ib: 1.17121272251 126 5
 ik, ib, ikeff, ibeff 126 0 126 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00451368053034
 Prefactor: 0.932142312786
 Exponent: 0.0702697798311
 Exponent/npoles: 0.0702697798311


 This state is empty! eqpkb ik ib: 1.0577533945 127 5
 ik, ib, ikeff, ibeff 127 0 127 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00339279395258
 Prefactor: 0.960277598423
 Exponent: 0.040532871296
 Exponent/npoles: 0.040532871296


 This state is empty! eqpkb ik ib: 1.83354127355 128 5
 ik, ib, ikeff, ibeff 128 0 128 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0133396345083
 Prefactor: 0.960281976501
 Exponent: 0.0405283121277
 Exponent/npoles: 0.0405283121277


 This state is empty! eqpkb ik ib: 1.85454983095 129 5
 ik, ib, ikeff, ibeff 129 0 129 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.006358365169
 Prefactor: 0.959295520786
 Exponent: 0.0415560964214
 Exponent/npoles: 0.0415560964214


 This state is empty! eqpkb ik ib: 1.81763 130 5
 ik, ib, ikeff, ibeff 130 0 130 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0110411415747
 Prefactor: 0.972653613941
 Exponent: 0.0277272581835
 Exponent/npoles: 0.0277272581835


 This state is empty! eqpkb ik ib: 2.47446873874 131 5
 ik, ib, ikeff, ibeff 131 0 131 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 2.75878251936e-05
 Prefactor: 0.875625978838
 Exponent: 0.132816244018
 Exponent/npoles: 0.132816244018


 This state is empty! eqpkb ik ib: 0.200613333333 132 5
 ik, ib, ikeff, ibeff 132 0 132 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00178680502235
 Prefactor: 0.926704410128
 Exponent: 0.0761206314407
 Exponent/npoles: 0.0761206314407


 This state is empty! eqpkb ik ib: 0.940127757256 133 5
 ik, ib, ikeff, ibeff 133 0 133 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00572587727941
 Prefactor: 0.955460774463
 Exponent: 0.0455615685118
 Exponent/npoles: 0.0455615685118


 This state is empty! eqpkb ik ib: 1.70928735677 134 5
 ik, ib, ikeff, ibeff 134 0 134 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00539203500746
 Prefactor: 0.953744799776
 Exponent: 0.047359148796
 Exponent/npoles: 0.047359148796


 This state is empty! eqpkb ik ib: 1.65676389831 135 5
 ik, ib, ikeff, ibeff 135 0 135 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00512019933612
 Prefactor: 0.970688026617
 Exponent: 0.0297501531322
 Exponent/npoles: 0.0297501531322


 This state is empty! eqpkb ik ib: 2.35864690231 136 5
 ik, ib, ikeff, ibeff 136 0 136 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0209516742668
 Prefactor: 0.97154527536
 Exponent: 0.0288674076895
 Exponent/npoles: 0.0288674076895


 This state is empty! eqpkb ik ib: 2.43638779137 137 5
 ik, ib, ikeff, ibeff 137 0 137 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00522818433759
 Prefactor: 0.980368275392
 Exponent: 0.0198269866933
 Exponent/npoles: 0.0198269866933


 This state is empty! eqpkb ik ib: 3.11352653087 138 5
 ik, ib, ikeff, ibeff 138 0 138 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00125260543129
 Prefactor: 0.951785218528
 Exponent: 0.0494158804349
 Exponent/npoles: 0.0494158804349


 This state is empty! eqpkb ik ib: 1.60121629243 139 5
 ik, ib, ikeff, ibeff 139 0 139 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00978026084268
 Prefactor: 0.968869587607
 Exponent: 0.031625260662
 Exponent/npoles: 0.031625260662


 This state is empty! eqpkb ik ib: 2.35201608247 140 5
 ik, ib, ikeff, ibeff 140 0 140 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00746638486298
 Prefactor: 0.979138994234
 Exponent: 0.0210816708054
 Exponent/npoles: 0.0210816708054


 This state is empty! eqpkb ik ib: 2.99913384615 141 5
 ik, ib, ikeff, ibeff 141 0 141 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0154463368719
 Prefactor: 0.979212697171
 Exponent: 0.021006400426
 Exponent/npoles: 0.021006400426


 This state is empty! eqpkb ik ib: 3.11061767471 142 5
 ik, ib, ikeff, ibeff 142 0 142 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00376065933362
 Prefactor: 0.978757136555
 Exponent: 0.0214717402041
 Exponent/npoles: 0.0214717402041


 This state is empty! eqpkb ik ib: 3.08534548673 143 5
 ik, ib, ikeff, ibeff 143 0 143 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.0103843817767
 Prefactor: 0.98473436328
 Exponent: 0.0153833561297
 Exponent/npoles: 0.0153833561297


 This state is empty! eqpkb ik ib: 3.75012385742 144 5
 ik, ib, ikeff, ibeff 144 0 144 4


 === Normalization test === 
 Prefactor*wtk*pdos*Gamma/pi: 0.00119299696095
 Prefactor: 0.988998617339
 Exponent: 0.0110623453995
 Exponent/npoles: 0.0110623453995


 This state is empty! eqpkb ik ib: 4.46446643533 145 5
 Used time (elaps, cpu): 2.701718e+02 2.699249e+02
 ### Writing out A(\omega)_exp...  

 A(\omega)_exp written in spftot_exp_s1.0_p0.0_800ev_np1.dat
 A(\omega)_CRC written in spftot_exp_s1.0_p0.0_800ev_np1_crc.dat
 Moving back to parent directory:
/home/zhou/CRC/CRC/sky_test
